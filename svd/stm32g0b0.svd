<!--
Copyright (c) 2020 STMicroelectronics.

 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
--><device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <name>STM32G0B0</name>
  <version>1.1</version>
  <description>STM32G0B0</description>
  <cpu>
    <name>CM0</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>0x20</size>
  <resetValue>0x0</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>CRC</name>
      <description>Cyclic redundancy check calculation
      unit</description>
      <groupName>CRC</groupName>
      <baseAddress>0x40023000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DR</name>
          <displayName>DR</displayName>
          <description>Data register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <fields>
            <field>
              <name>DR</name>
              <description>Data register bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <displayName>IDR</displayName>
          <description>Independent data register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDR</name>
              <description>General-purpose 32-bit data register
              bits</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
            <name>REV_OUT</name>
            <description>Reverse output data
This bit controls the reversal of the bit order of the output data.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
            <field>
            <name>REV_IN</name>
            <description>Reverse input data
These bits control the reversal of the bit order of the input data</description>
            <bitOffset>5</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
            <field>
            <name>POLYSIZE</name>
            <description>Polynomial size
These bits control the size of the polynomial.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
            <field>
              <name>RESET</name>
              <description>RESET bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <displayName>INIT</displayName>
          <description>Initial CRC value</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <fields>
            <field>
              <name>CRC_INIT</name>
              <description>Programmable initial CRC
              value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>POL</name>
          <displayName>POL</displayName>
          <description>polynomial</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x04C11DB7</resetValue>
          <fields>
            <field>
              <name>POL</name>
              <description>Programmable polynomial</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
	<peripheral>
        <name>DBG</name>
        <description>Debug support</description>
        <groupName>DBG</groupName>
        <baseAddress>0x40015800</baseAddress>
        <addressBlock>
          <offset>0x0</offset>
          <size>0x400</size>
          <usage>registers</usage>
        </addressBlock>
        <registers>
		  <register>
            <name>IDCODE</name>
            <displayName>IDCODE</displayName>
            <description>MCU Device ID Code Register</description>
            <addressOffset>0x0</addressOffset>
            <size>0x20</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <fields>
              <field>
                <name>DEV_ID</name>
                <description>Device Identifier</description>
                <bitOffset>0</bitOffset>
                <bitWidth>12</bitWidth>
              </field>
              <field>
                <name>REV_ID</name>
                <description>Revision Identifier</description>
                <bitOffset>16</bitOffset>
                <bitWidth>16</bitWidth>
              </field>
            </fields>
          </register>
          <register>
            <name>CR</name>
            <displayName>CR</displayName>
            <description>DBG configuration register </description>
            <addressOffset>0x4</addressOffset>
            <size>0x20</size>
			<access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <fields>
              <field>
                <name>DBG_STOP</name>
                <description>Debug Stop mode
Debug options in Stop mode.
Upon Stop mode exit, the software must re-establish the desired clock configuration.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_STANDBY</name>
                <description>Debug Standby and Shutdown modes
Debug options in Standby or Shutdown mode.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
            </fields>
          </register>
          <register>
            <name>APB_FZ1</name>
            <displayName>APB_FZ1</displayName>
            <description>DBG APB freeze register 1 </description>
            <addressOffset>0x8</addressOffset>
            <size>0x20</size>
			<access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <fields>
              <field>
                <name>DBG_TIM2_STOP</name>
                <description>Clocking of TIM2 counter when the core is halted
This bit enables/disables the clock to the counter of TIM2 when the core is halted:</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM3_STOP</name>
                <description>Clocking of TIM3 counter when the core is halted
This bit enables/disables the clock to the counter of TIM3 when the core is halted:</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM6_STOP</name>
                <description>Clocking of TIM6 counter when the core is halted
This bit enables/disables the clock to the counter of TIM6 when the core is halted:</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM7_STOP</name>
                <description>Clocking of TIM7 counter when the core is halted.
This bit enables/disables the clock to the counter of ITIM7 when the core is halted:</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_RTC_STOP</name>
                <description>Clocking of RTC counter when the core is halted
This bit enables/disables the clock to the counter of RTC when the core is halted:</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_WWDG_STOP</name>
                <description>Clocking of WWDG counter when the core is halted
This bit enables/disables the clock to the counter of WWDG when the core is halted:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_IWDG_STOP</name>
                <description>Clocking of IWDG counter when the core is halted
This bit enables/disables the clock to the counter of IWDG when the core is halted:</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_I2C1_SMBUS_TIMEOUT</name>
                <description>SMBUS timeout when core is halted</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_LPTIM2_STOP</name>
                <description>Clocking of LPTIMER2 counter when the core is halted
This bit enables/disables the clock to the counter of LPTIMER2 when the core is halted:</description>
                <bitOffset>30</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_LPTIM1_STOP</name>
                <description>Clocking of LPTIMER1 counter when the core is halted
This bit enables/disables the clock to the counter of LPTIMER1 when the core is halted:</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
            </fields>
          </register>
          <register>
            <name>APB_FZ2</name>
            <displayName>APB_FZ2</displayName>
            <description>DBG APB freeze register 2 </description>
            <addressOffset>0xc</addressOffset>
            <size>0x20</size>
			<access>read-write</access>
            <resetValue>0x00000000</resetValue>
            <fields>
              <field>
                <name>DBG_TIM1_STOP</name>
                <description>Clocking of TIM1 counter when the core is halted
This bit enables/disables the clock to the counter of TIM1 when the core is halted:</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM14_STOP</name>
                <description>Clocking of TIM14 counter when the core is halted
This bit enables/disables the clock to the counter of TIM14 when the core is halted:</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM15_STOP</name>
                <description>Clocking of TIM15 counter when the core is halted
This bit enables/disables the clock to the counter of TIM15 when the core is halted:
Only available on STM32G071xx and STM32G081xx, reserved on STM32G031xx and STM32G041xx.</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM16_STOP</name>
                <description>Clocking of TIM16 counter when the core is halted
This bit enables/disables the clock to the counter of TIM16 when the core is halted:</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DBG_TIM17_STOP</name>
                <description>Clocking of TIM17 counter when the core is halted
This bit enables/disables the clock to the counter of TIM17 when the core is halted:</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
            </fields>
          </register>
        </registers>
    </peripheral>
	<peripheral>
      <name>DMAMUX</name>
      <description>DMAMUX</description>
      <groupName>DMAMUX</groupName>
      <baseAddress>0x40020800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>DMA_Channel4_5_6_7</name>
        <description>DMA channel 4, 5, 6 &amp; 7 and
        DMAMUX</description>
        <value>11</value>
      </interrupt>
      <registers>
        <register>
          <name>C0CR</name>
          <displayName>C0CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
			  <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
          </fields>
        </register>
        <register>
          <name>C1CR</name>
          <displayName>C1CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		      <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
          </fields>
        </register>
        <register>
          <name>C2CR</name>
          <displayName>C2CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
			  <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
          </fields>
        </register>
        <register>
          <name>C3CR</name>
          <displayName>C3CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
	         <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>  
		  </fields>
        </register>
        <register>
          <name>C4CR</name>
          <displayName>C4CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
			  <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
          </fields>
        </register>
        <register>
          <name>C5CR</name>
          <displayName>C5CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
			  <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
          </fields>
        </register>
        <register>
          <name>C6CR</name>
          <displayName>C6CR</displayName>
          <description>DMAMUX request line multiplexer channel x configuration register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
			  <field>
				<name>DMAREQ_ID</name>
				<description>DMA request identification
	Selects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources.</description>
				<bitOffset>0</bitOffset>
				<bitWidth>6</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SOIE</name>
				<description>Synchronization overrun interrupt enable</description>
				<bitOffset>8</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>EGE</name>
				<description>Event generation enable</description>
				<bitOffset>9</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SE</name>
				<description>Synchronization enable</description>
				<bitOffset>16</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>SPOL</name>
				<description>Synchronization polarity
	Defines the edge polarity of the selected synchronization input:</description>
				<bitOffset>17</bitOffset>
				<bitWidth>2</bitWidth>
				<access>read-write</access>
				</field>
			  <field>
				<name>NBREQ</name>
				<description>Number of DMA requests minus 1 to forward
	Defines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.
	This field shall only be written when both SE and EGE bits are low.</description>
				<bitOffset>19</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
			  <field>
				<name>SYNC_ID</name>
				<description>Synchronization identification
	Selects the synchronization input (see inputs to resources STM32G0).</description>
				<bitOffset>24</bitOffset>
				<bitWidth>5</bitWidth>
				<access>read-write</access>
			  </field>
          </fields>
        </register>
		<register>
          <name>CSR</name>
		  <displayName>CSR</displayName>
          <description>DMAMUX request line multiplexer interrupt channel status register</description>
          <addressOffset>0x80</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
		  <fields>
			  <field>
				<name>SOF0</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>0</bitOffset>				
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
			  <field>
				<name>SOF1</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>1</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
			  <field>
				<name>SOF2</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>2</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
			  <field>
				<name>SOF3</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>3</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
			  <field>
				<name>SOF4</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>4</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
			  <field>
				<name>SOF5</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>5</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
			  <field>
				<name>SOF6</name>
				<description>Synchronization overrun event flag
	The flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.
	The flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register.</description>
				<bitOffset>6</bitOffset>
				<bitWidth>1</bitWidth>
				<access>read-only</access>
			  </field>
		  </fields>
        </register>
		<register>
          <name>CFR</name>
          <displayName>CFR</displayName>
		  <description>DMAMUX request line multiplexer interrupt clear flag register</description>
          <addressOffset>0x84</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
		  <fields>
          <field>
            <name>CSOF0</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>0</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CSOF1</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>1</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CSOF2</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>2</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CSOF3</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>3</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CSOF4</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>4</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CSOF5</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>5</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CSOF6</name>
            <description>Clear synchronization overrun event flag
Writing 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register.</description>
            <bitOffset>6</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
		  </fields>
        </register>		
        <register>
          <name>RG0CR</name>
          <displayName>RG0CR</displayName>
          <description>DMAMUX request generator channel x configuration register</description>
          <addressOffset>0x100</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>SIG_ID</name>
            <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIE</name>
            <description>Trigger overrun interrupt enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GE</name>
            <description>DMA request generator channel x enable</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GPOL</name>
            <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
            <bitOffset>17</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GNBREQ</name>
            <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field shall only be written when GE bit is disabled.</description>
            <bitOffset>19</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>RG1CR</name>
          <displayName>RG1CR</displayName>
          <description>DMAMUX request generator channel x configuration register</description>
          <addressOffset>0x104</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>SIG_ID</name>
            <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIE</name>
            <description>Trigger overrun interrupt enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GE</name>
            <description>DMA request generator channel x enable</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GPOL</name>
            <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
            <bitOffset>17</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GNBREQ</name>
            <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field shall only be written when GE bit is disabled.</description>
            <bitOffset>19</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>RG2CR</name>
          <displayName>RG2CR</displayName>
          <description>DMAMUX request generator channel x configuration register</description>
          <addressOffset>0x108</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>SIG_ID</name>
            <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIE</name>
            <description>Trigger overrun interrupt enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GE</name>
            <description>DMA request generator channel x enable</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GPOL</name>
            <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
            <bitOffset>17</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GNBREQ</name>
            <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field shall only be written when GE bit is disabled.</description>
            <bitOffset>19</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>RG3CR</name>
          <displayName>RG3CR</displayName>
          <description>DMAMUX request generator channel x configuration register</description>
          <addressOffset>0x10C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>SIG_ID</name>
            <description>Signal identification
Selects the DMA request trigger input used for the channel x of the DMA request generator</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIE</name>
            <description>Trigger overrun interrupt enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GE</name>
            <description>DMA request generator channel x enable</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GPOL</name>
            <description>DMA request generator trigger polarity
Defines the edge polarity of the selected trigger input</description>
            <bitOffset>17</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GNBREQ</name>
            <description>Number of DMA requests to be generated (minus 1)
Defines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.
Note: This field shall only be written when GE bit is disabled.</description>
            <bitOffset>19</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field> 
          </fields>
        </register>
        <register>
          <name>RGSR</name>
          <displayName>RGSR</displayName>
          <description>DMAMUX request generator interrupt status register</description>
          <addressOffset>0x140</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>OF0</name>
            <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
            <bitOffset>0</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>OF1</name>
            <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
            <bitOffset>1</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>OF2</name>
            <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
            <bitOffset>2</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>OF3</name>
            <description>Trigger overrun event flag
The flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).
The flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register.</description>
            <bitOffset>3</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          </fields>
        </register>
        <register>
          <name>RGCFR</name>
          <displayName>RGCFR</displayName>
          <description>DMAMUX request generator interrupt clear flag register</description>
          <addressOffset>0x144</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>COF0</name>
            <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
            <bitOffset>0</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>COF1</name>
            <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
            <bitOffset>1</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>COF2</name>
            <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
            <bitOffset>2</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>COF3</name>
            <description>Clear trigger overrun event flag
Writing 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register.</description>
            <bitOffset>3</bitOffset>
           
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          </fields>
        </register>
      </registers>
    </peripheral>
	<peripheral>
      <name>GPIOA</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50000000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MODER</name>
          <displayName>MODER</displayName>
          <description>GPIO port mode register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xEBFFFFFF</resetValue>
          <fields>
            <field>
              <name>MODER15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues><name>MODER0</name><usage>read-write</usage><enumeratedValue><name>Input</name><description>Input mode</description><value>0</value></enumeratedValue><enumeratedValue><name>Output</name><description>General purpose output mode</description><value>1</value></enumeratedValue><enumeratedValue><name>Alternate</name><description>Alternate function mode</description><value>2</value></enumeratedValue><enumeratedValue><name>Analog</name><description>Analog mode</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OTYPER</name>
          <displayName>OTYPER</displayName>
          <description>GPIO port output type register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OT15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>OT0</name><usage>read-write</usage><enumeratedValue><name>PushPull</name><description>Output push-pull (reset state)</description><value>0</value></enumeratedValue><enumeratedValue><name>OpenDrain</name><description>Output open-drain</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPEEDR</name>
          <displayName>OSPEEDR</displayName>
          <description>GPIO port output speed
          register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0C000000</resetValue>
          <fields>
            <field>
              <name>OSPEEDR15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues><name>OSPEEDR0</name><usage>read-write</usage><enumeratedValue><name>LowSpeed</name><description>Low speed</description><value>0</value></enumeratedValue><enumeratedValue><name>MediumSpeed</name><description>Medium speed</description><value>1</value></enumeratedValue><enumeratedValue><name>HighSpeed</name><description>High speed</description><value>2</value></enumeratedValue><enumeratedValue><name>VeryHighSpeed</name><description>Very high speed</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PUPDR</name>
          <displayName>PUPDR</displayName>
          <description>GPIO port pull-up/pull-down
          register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x24000000</resetValue>
          <fields>
            <field>
              <name>PUPDR15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues><name>PUPDR0</name><usage>read-write</usage><enumeratedValue><name>Floating</name><description>No pull-up, pull-down</description><value>0</value></enumeratedValue><enumeratedValue><name>PullUp</name><description>Pull-up</description><value>1</value></enumeratedValue><enumeratedValue><name>PullDown</name><description>Pull-down</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <displayName>IDR</displayName>
          <description>GPIO port input data register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDR15</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR14</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR13</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR12</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR11</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR10</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR9</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR8</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR7</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR6</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR5</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR4</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR3</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR2</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR1</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR0</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>IDR0</name><usage>read-write</usage><enumeratedValue><name>High</name><description>Input is logic high</description><value>1</value></enumeratedValue><enumeratedValue><name>Low</name><description>Input is logic low</description><value>0</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ODR</name>
          <displayName>ODR</displayName>
          <description>GPIO port output data register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ODR15</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR14</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR13</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR12</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR11</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR10</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR9</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR8</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR7</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR6</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR5</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR4</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR3</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR2</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR1</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR0</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>ODR0</name><usage>read-write</usage><enumeratedValue><name>High</name><description>Set output to logic high</description><value>1</value></enumeratedValue><enumeratedValue><name>Low</name><description>Set output to logic low</description><value>0</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>BSRR</name>
          <displayName>BSRR</displayName>
          <description>GPIO port bit set/reset
          register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BR15</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR14</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR13</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR12</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR11</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR10</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR9</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR8</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR7</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR6</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR5</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR4</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR3</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR2</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR1</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR0</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BR0W</name><usage>write</usage><enumeratedValue><name>Reset</name><description>Resets the corresponding ODx bit</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BS15</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS14</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS13</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS12</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS11</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS10</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS9</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS8</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS7</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS6</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS5</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS4</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS3</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS2</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS1</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS0</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BS0W</name><usage>write</usage><enumeratedValue><name>Set</name><description>Sets the corresponding ODx bit</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LCKR</name>
          <displayName>LCKR</displayName>
          <description>GPIO port configuration lock
          register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LCKK</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>LCKK</name><usage>read-write</usage><enumeratedValue><name>NotActive</name><description>Port configuration lock key not active</description><value>0</value></enumeratedValue><enumeratedValue><name>Active</name><description>Port configuration lock key active</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>LCK15</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK14</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK13</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK12</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK11</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK10</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK9</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK8</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK7</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK6</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK5</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK4</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK3</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK2</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK1</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK0</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>LCK0</name><usage>read-write</usage><enumeratedValue><name>Unlocked</name><description>Port configuration not locked</description><value>0</value></enumeratedValue><enumeratedValue><name>Locked</name><description>Port configuration locked</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AFRL</name>
          <displayName>AFRL</displayName>
          <description>GPIO alternate function low
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AFSEL7</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL6</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL5</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL4</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL3</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL2</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL1</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL0</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues><name>AFSEL0</name><usage>read-write</usage><enumeratedValue><name>AF0</name><description>AF0</description><value>0</value></enumeratedValue><enumeratedValue><name>AF1</name><description>AF1</description><value>1</value></enumeratedValue><enumeratedValue><name>AF2</name><description>AF2</description><value>2</value></enumeratedValue><enumeratedValue><name>AF3</name><description>AF3</description><value>3</value></enumeratedValue><enumeratedValue><name>AF4</name><description>AF4</description><value>4</value></enumeratedValue><enumeratedValue><name>AF5</name><description>AF5</description><value>5</value></enumeratedValue><enumeratedValue><name>AF6</name><description>AF6</description><value>6</value></enumeratedValue><enumeratedValue><name>AF7</name><description>AF7</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AFRH</name>
          <displayName>AFRH</displayName>
          <description>GPIO alternate function high
          register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AFSEL15</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL14</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL13</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL12</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL11</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL10</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL9</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL8</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues><name>AFSEL8</name><usage>read-write</usage><enumeratedValue><name>AF0</name><description>AF0</description><value>0</value></enumeratedValue><enumeratedValue><name>AF1</name><description>AF1</description><value>1</value></enumeratedValue><enumeratedValue><name>AF2</name><description>AF2</description><value>2</value></enumeratedValue><enumeratedValue><name>AF3</name><description>AF3</description><value>3</value></enumeratedValue><enumeratedValue><name>AF4</name><description>AF4</description><value>4</value></enumeratedValue><enumeratedValue><name>AF5</name><description>AF5</description><value>5</value></enumeratedValue><enumeratedValue><name>AF6</name><description>AF6</description><value>6</value></enumeratedValue><enumeratedValue><name>AF7</name><description>AF7</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>port bit reset register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BR0</name>
              <description>Port Reset bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BR0W</name><usage>write</usage><enumeratedValue><name>NoAction</name><description>No action on the corresponding ODx bit</description><value>0</value></enumeratedValue><enumeratedValue><name>Reset</name><description>Reset the ODx bit</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BR1</name>
              <description>Port Reset bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR2</name>
              <description>Port Reset bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR3</name>
              <description>Port Reset bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR4</name>
              <description>Port Reset bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR5</name>
              <description>Port Reset bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR6</name>
              <description>Port Reset bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR7</name>
              <description>Port Reset bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR8</name>
              <description>Port Reset bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR9</name>
              <description>Port Reset bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR10</name>
              <description>Port Reset bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR11</name>
              <description>Port Reset bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR12</name>
              <description>Port Reset bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR13</name>
              <description>Port Reset bit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR14</name>
              <description>Port Reset bit</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR15</name>
              <description>Port Reset bit</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIOB</name>
      <description>General-purpose I/Os</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50000400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>MODER</name>
          <displayName>MODER</displayName>
          <description>GPIO port mode register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <fields>
            <field>
              <name>MODER15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="MODER0"/>
            </field>
            <field>
              <name>MODER0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues><name>MODER0</name><usage>read-write</usage><enumeratedValue><name>Input</name><description>Input mode</description><value>0</value></enumeratedValue><enumeratedValue><name>Output</name><description>General purpose output mode</description><value>1</value></enumeratedValue><enumeratedValue><name>Alternate</name><description>Alternate function mode</description><value>2</value></enumeratedValue><enumeratedValue><name>Analog</name><description>Analog mode</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OTYPER</name>
          <displayName>OTYPER</displayName>
          <description>GPIO port output type register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OT15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OT0"/>
            </field>
            <field>
              <name>OT0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>OT0</name><usage>read-write</usage><enumeratedValue><name>PushPull</name><description>Output push-pull (reset state)</description><value>0</value></enumeratedValue><enumeratedValue><name>OpenDrain</name><description>Output open-drain</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OSPEEDR</name>
          <displayName>OSPEEDR</displayName>
          <description>GPIO port output speed
          register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OSPEEDR15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="OSPEEDR0"/>
            </field>
            <field>
              <name>OSPEEDR0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues><name>OSPEEDR0</name><usage>read-write</usage><enumeratedValue><name>LowSpeed</name><description>Low speed</description><value>0</value></enumeratedValue><enumeratedValue><name>MediumSpeed</name><description>Medium speed</description><value>1</value></enumeratedValue><enumeratedValue><name>HighSpeed</name><description>High speed</description><value>2</value></enumeratedValue><enumeratedValue><name>VeryHighSpeed</name><description>Very high speed</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PUPDR</name>
          <displayName>PUPDR</displayName>
          <description>GPIO port pull-up/pull-down
          register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PUPDR15</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR14</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR13</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR12</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR11</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR10</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR9</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR8</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR7</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR6</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR5</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR4</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR3</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR2</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR1</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues derivedFrom="PUPDR0"/>
            </field>
            <field>
              <name>PUPDR0</name>
              <description>Port x configuration bits (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            <enumeratedValues><name>PUPDR0</name><usage>read-write</usage><enumeratedValue><name>Floating</name><description>No pull-up, pull-down</description><value>0</value></enumeratedValue><enumeratedValue><name>PullUp</name><description>Pull-up</description><value>1</value></enumeratedValue><enumeratedValue><name>PullDown</name><description>Pull-down</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>IDR</name>
          <displayName>IDR</displayName>
          <description>GPIO port input data register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IDR15</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR14</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR13</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR12</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR11</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR10</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR9</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR8</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR7</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR6</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR5</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR4</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR3</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR2</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR1</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="IDR0"/>
            </field>
            <field>
              <name>IDR0</name>
              <description>Port input data (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>IDR0</name><usage>read-write</usage><enumeratedValue><name>High</name><description>Input is logic high</description><value>1</value></enumeratedValue><enumeratedValue><name>Low</name><description>Input is logic low</description><value>0</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ODR</name>
          <displayName>ODR</displayName>
          <description>GPIO port output data register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ODR15</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR14</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR13</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR12</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR11</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR10</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR9</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR8</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR7</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR6</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR5</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR4</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR3</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR2</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR1</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="ODR0"/>
            </field>
            <field>
              <name>ODR0</name>
              <description>Port output data (y =
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>ODR0</name><usage>read-write</usage><enumeratedValue><name>High</name><description>Set output to logic high</description><value>1</value></enumeratedValue><enumeratedValue><name>Low</name><description>Set output to logic low</description><value>0</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>BSRR</name>
          <displayName>BSRR</displayName>
          <description>GPIO port bit set/reset
          register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BR15</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR14</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR13</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR12</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR11</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR10</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR9</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR8</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR7</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR6</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR5</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR4</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR3</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR2</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR1</name>
              <description>Port x reset bit y (y =
              0..15)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR0</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BR0W</name><usage>write</usage><enumeratedValue><name>Reset</name><description>Resets the corresponding ODx bit</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BS15</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS14</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS13</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS12</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS11</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS10</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS9</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS8</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS7</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS6</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS5</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS4</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS3</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS2</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS1</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BS0W"/>
            </field>
            <field>
              <name>BS0</name>
              <description>Port x set bit y (y=
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BS0W</name><usage>write</usage><enumeratedValue><name>Set</name><description>Sets the corresponding ODx bit</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LCKR</name>
          <displayName>LCKR</displayName>
          <description>GPIO port configuration lock
          register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>LCKK</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>LCKK</name><usage>read-write</usage><enumeratedValue><name>NotActive</name><description>Port configuration lock key not active</description><value>0</value></enumeratedValue><enumeratedValue><name>Active</name><description>Port configuration lock key active</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>LCK15</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK14</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK13</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK12</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK11</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK10</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK9</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK8</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK7</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK6</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK5</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK4</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK3</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK2</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK1</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="LCK0"/>
            </field>
            <field>
              <name>LCK0</name>
              <description>Port x lock bit y (y=
              0..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>LCK0</name><usage>read-write</usage><enumeratedValue><name>Unlocked</name><description>Port configuration not locked</description><value>0</value></enumeratedValue><enumeratedValue><name>Locked</name><description>Port configuration locked</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AFRL</name>
          <displayName>AFRL</displayName>
          <description>GPIO alternate function low
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AFSEL7</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL6</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL5</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL4</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL3</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL2</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL1</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL0"/>
            </field>
            <field>
              <name>AFSEL0</name>
              <description>Alternate function selection for port x
              bit y (y = 0..7)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues><name>AFSEL0</name><usage>read-write</usage><enumeratedValue><name>AF0</name><description>AF0</description><value>0</value></enumeratedValue><enumeratedValue><name>AF1</name><description>AF1</description><value>1</value></enumeratedValue><enumeratedValue><name>AF2</name><description>AF2</description><value>2</value></enumeratedValue><enumeratedValue><name>AF3</name><description>AF3</description><value>3</value></enumeratedValue><enumeratedValue><name>AF4</name><description>AF4</description><value>4</value></enumeratedValue><enumeratedValue><name>AF5</name><description>AF5</description><value>5</value></enumeratedValue><enumeratedValue><name>AF6</name><description>AF6</description><value>6</value></enumeratedValue><enumeratedValue><name>AF7</name><description>AF7</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>AFRH</name>
          <displayName>AFRH</displayName>
          <description>GPIO alternate function high
          register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>AFSEL15</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL14</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL13</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL12</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL11</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL10</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL9</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues derivedFrom="AFSEL8"/>
            </field>
            <field>
              <name>AFSEL8</name>
              <description>Alternate function selection for port x
              bit y (y = 8..15)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
            <enumeratedValues><name>AFSEL8</name><usage>read-write</usage><enumeratedValue><name>AF0</name><description>AF0</description><value>0</value></enumeratedValue><enumeratedValue><name>AF1</name><description>AF1</description><value>1</value></enumeratedValue><enumeratedValue><name>AF2</name><description>AF2</description><value>2</value></enumeratedValue><enumeratedValue><name>AF3</name><description>AF3</description><value>3</value></enumeratedValue><enumeratedValue><name>AF4</name><description>AF4</description><value>4</value></enumeratedValue><enumeratedValue><name>AF5</name><description>AF5</description><value>5</value></enumeratedValue><enumeratedValue><name>AF6</name><description>AF6</description><value>6</value></enumeratedValue><enumeratedValue><name>AF7</name><description>AF7</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>port bit reset register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>BR0</name>
              <description>Port Reset bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BR0W</name><usage>write</usage><enumeratedValue><name>NoAction</name><description>No action on the corresponding ODx bit</description><value>0</value></enumeratedValue><enumeratedValue><name>Reset</name><description>Reset the ODx bit</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BR1</name>
              <description>Port Reset bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR2</name>
              <description>Port Reset bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR3</name>
              <description>Port Reset bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR4</name>
              <description>Port Reset bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR5</name>
              <description>Port Reset bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR6</name>
              <description>Port Reset bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR7</name>
              <description>Port Reset bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR8</name>
              <description>Port Reset bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR9</name>
              <description>Port Reset bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR10</name>
              <description>Port Reset bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR11</name>
              <description>Port Reset bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR12</name>
              <description>Port Reset bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR13</name>
              <description>Port Reset bit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR14</name>
              <description>Port Reset bit</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
            <field>
              <name>BR15</name>
              <description>Port Reset bit</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="BR0W"/>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="GPIOB">
      <name>GPIOC</name>
      <baseAddress>0x50000800</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPIOB">
      <name>GPIOD</name>
      <baseAddress>0x50000C00</baseAddress>
    </peripheral>
	<peripheral derivedFrom="GPIOB">
      <name>GPIOE</name>
      <baseAddress>0x50001000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="GPIOB">
      <name>GPIOF</name>
      <baseAddress>0x50001400</baseAddress>
    </peripheral>
	<peripheral>
      <name>I2C1</name>
      <description>Inter-integrated circuit</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40005400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>I2C1</name>
        <description>I2C1 global interrupt</description>
        <value>23</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>Control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>PE</name>
            <description>Peripheral enable
Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>PE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Peripheral disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Peripheral enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>TXIE</name>
            <description>TX Interrupt enable</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>TXIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Transmit (TXIS) interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Transmit (TXIS) interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>RXIE</name>
            <description>RX Interrupt enable</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>RXIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Receive (RXNE) interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Receive (RXNE) interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ADDRIE</name>
            <description>Address match Interrupt enable (slave only)</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ADDRIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Address match (ADDR) interrupts disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Address match (ADDR) interrupts enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>NACKIE</name>
            <description>Not acknowledge received Interrupt enable</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>NACKIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Not acknowledge (NACKF) received interrupts disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Not acknowledge (NACKF) received interrupts enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>STOPIE</name>
            <description>Stop detection Interrupt enable</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>STOPIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Stop detection (STOPF) interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Stop detection (STOPF) interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>TCIE</name>
            <description>Transfer Complete interrupt enable
Note: Any of these events generate an interrupt:
Transfer Complete (TC)
Transfer Complete Reload (TCR)</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>TCIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Transfer Complete interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Transfer Complete interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ERRIE</name>
            <description>Error interrupts enable
Note: Any of these errors generate an interrupt:
Arbitration Loss (ARLO)
Bus Error detection (BERR)
Overrun/Underrun (OVR)
Timeout detection (TIMEOUT)
PEC error detection (PECERR)
Alert pin event detection (ALERT)</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ERRIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Error detection interrupts disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Error detection interrupts enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>DNF</name>
            <description>Digital noise filter
These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK
...
Note: If the analog filter is also enabled, the digital filter is added to the analog filter.
This filter can only be programmed when the I2C is disabled (PE = 0).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>DNF</name><usage>read-write</usage><enumeratedValue><name>NoFilter</name><description>Digital filter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Filter1</name><description>Digital filter enabled and filtering capability up to 1 tI2CCLK</description><value>1</value></enumeratedValue><enumeratedValue><name>Filter2</name><description>Digital filter enabled and filtering capability up to 2 tI2CCLK</description><value>2</value></enumeratedValue><enumeratedValue><name>Filter3</name><description>Digital filter enabled and filtering capability up to 3 tI2CCLK</description><value>3</value></enumeratedValue><enumeratedValue><name>Filter4</name><description>Digital filter enabled and filtering capability up to 4 tI2CCLK</description><value>4</value></enumeratedValue><enumeratedValue><name>Filter5</name><description>Digital filter enabled and filtering capability up to 5 tI2CCLK</description><value>5</value></enumeratedValue><enumeratedValue><name>Filter6</name><description>Digital filter enabled and filtering capability up to 6 tI2CCLK</description><value>6</value></enumeratedValue><enumeratedValue><name>Filter7</name><description>Digital filter enabled and filtering capability up to 7 tI2CCLK</description><value>7</value></enumeratedValue><enumeratedValue><name>Filter8</name><description>Digital filter enabled and filtering capability up to 8 tI2CCLK</description><value>8</value></enumeratedValue><enumeratedValue><name>Filter9</name><description>Digital filter enabled and filtering capability up to 9 tI2CCLK</description><value>9</value></enumeratedValue><enumeratedValue><name>Filter10</name><description>Digital filter enabled and filtering capability up to 10 tI2CCLK</description><value>10</value></enumeratedValue><enumeratedValue><name>Filter11</name><description>Digital filter enabled and filtering capability up to 11 tI2CCLK</description><value>11</value></enumeratedValue><enumeratedValue><name>Filter12</name><description>Digital filter enabled and filtering capability up to 12 tI2CCLK</description><value>12</value></enumeratedValue><enumeratedValue><name>Filter13</name><description>Digital filter enabled and filtering capability up to 13 tI2CCLK</description><value>13</value></enumeratedValue><enumeratedValue><name>Filter14</name><description>Digital filter enabled and filtering capability up to 14 tI2CCLK</description><value>14</value></enumeratedValue><enumeratedValue><name>Filter15</name><description>Digital filter enabled and filtering capability up to 15 tI2CCLK</description><value>15</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ANFOFF</name>
            <description>Analog noise filter OFF
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ANFOFF</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Analog noise filter enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Analog noise filter disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>TXDMAEN</name>
            <description>DMA transmission requests enable</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>TXDMAEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>DMA mode disabled for transmission</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>DMA mode enabled for transmission</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>RXDMAEN</name>
            <description>DMA reception requests enable</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>RXDMAEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>DMA mode disabled for reception</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>DMA mode enabled for reception</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>SBC</name>
            <description>Slave byte control
This bit is used to enable hardware byte control in slave mode.</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>SBC</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Slave byte control disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Slave byte control enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>NOSTRETCH</name>
            <description>Clock stretching disable
This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.
Note: This bit can only be programmed when the I2C is disabled (PE = 0).</description>
            <bitOffset>17</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>NOSTRETCH</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Clock stretching enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Clock stretching disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>WUPEN</name>
            <description>Wakeup from Stop mode enable
Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0&#226;&#128;&#153;. Refer to .
Note: WUPEN can be set only when DNF = '0000&#226;&#128;&#153;</description>
            <bitOffset>18</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>WUPEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Wakeup from Stop mode disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Wakeup from Stop mode enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>GCEN</name>
            <description>General call enable</description>
            <bitOffset>19</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>GCEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>General call disabled. Address 0b00000000 is NACKed</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>General call enabled. Address 0b00000000 is ACKed</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>SMBHEN</name>
            <description>SMBus Host Address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0&#226;&#128;&#153;. Refer to .</description>
            <bitOffset>20</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>SMBHEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Host address disabled. Address 0b0001000x is NACKed</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Host address enabled. Address 0b0001000x is ACKed</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>SMBDEN</name>
            <description>SMBus Device Default Address enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0&#226;&#128;&#153;. Refer to .</description>
            <bitOffset>21</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>SMBDEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Device default address disabled. Address 0b1100001x is NACKed</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Device default address enabled. Address 0b1100001x is ACKed</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ALERTEN</name>
            <description>SMBus alert enable
Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0&#226;&#128;&#153;. Refer to .</description>
            <bitOffset>22</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ALERTEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>In device mode (SMBHEN=Disabled) Releases SMBA pin high and Alert Response Address Header disabled (0001100x) followed by NACK. In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) not supported</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>In device mode (SMBHEN=Disabled) Drives SMBA pin low and Alert Response Address Header enabled (0001100x) followed by ACK.In host mode (SMBHEN=Enabled) SMBus Alert pin (SMBA) supported</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>PECEN</name>
            <description>PEC enable
Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0&#226;&#128;&#153;. Refer to .</description>
            <bitOffset>23</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>PECEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>PEC calculation disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>PEC calculation enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>SADD</name>
            <description>Slave address (master mode)
In 7-bit addressing mode (ADD10 = 0):
SADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.
In 10-bit addressing mode (ADD10 = 1):
SADD[9:0] should be written with the 10-bit slave address to be sent.
Note: Changing these bits when the START bit is set is not allowed.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>10</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>1023</maximum></range></writeConstraint>
            </field>
          <field>
            <name>RD_WRN</name>
            <description>Transfer direction (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>RD_WRN</name><usage>read-write</usage><enumeratedValue><name>Write</name><description>Master requests a write transfer</description><value>0</value></enumeratedValue><enumeratedValue><name>Read</name><description>Master requests a read transfer</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ADD10</name>
            <description>10-bit addressing mode (master mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ADD10</name><usage>read-write</usage><enumeratedValue><name>Bit7</name><description>The master operates in 7-bit addressing mode</description><value>0</value></enumeratedValue><enumeratedValue><name>Bit10</name><description>The master operates in 10-bit addressing mode</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>HEAD10R</name>
            <description>10-bit address header only read direction (master receiver mode)
Note: Changing this bit when the START bit is set is not allowed.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>HEAD10R</name><usage>read-write</usage><enumeratedValue><name>Complete</name><description>The master sends the complete 10 bit slave address read sequence</description><value>0</value></enumeratedValue><enumeratedValue><name>Partial</name><description>The master only sends the 1st 7 bits of the 10 bit address, followed by Read direction</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>START</name>
            <description>Start generation
This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1&#226;&#128;&#153; to the ADDRCF bit in the I2C_ICR register.
If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.
Otherwise setting this bit generates a START condition once the bus is free.
Note: Writing '0&#226;&#128;&#153; to this bit has no effect.
The START bit can be set even if the bus is BUSY or I2C is in slave mode.
This bit has no effect when RELOAD is set.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>START</name><usage>read-write</usage><enumeratedValue><name>NoStart</name><description>No Start generation</description><value>0</value></enumeratedValue><enumeratedValue><name>Start</name><description>Restart/Start generation</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>STOP</name>
            <description>Stop generation (master mode)
The bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.
In Master Mode:
Note: Writing '0&#226;&#128;&#153; to this bit has no effect.</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>STOP</name><usage>read-write</usage><enumeratedValue><name>NoStop</name><description>No Stop generation</description><value>0</value></enumeratedValue><enumeratedValue><name>Stop</name><description>Stop generation after current byte transfer</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>NACK</name>
            <description>NACK generation (slave mode)
The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0.
Note: Writing '0&#226;&#128;&#153; to this bit has no effect.
This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.
When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.
When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>NACK</name><usage>read-write</usage><enumeratedValue><name>Ack</name><description>an ACK is sent after current received byte</description><value>0</value></enumeratedValue><enumeratedValue><name>Nack</name><description>a NACK is sent after current received byte</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>NBYTES</name>
            <description>Number of bytes
The number of bytes to be transmitted/received is programmed there. This field is don&#226;&#128;&#153;t care in slave mode with SBC=0.
Note: Changing these bits when the START bit is set is not allowed.</description>
            <bitOffset>16</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>255</maximum></range></writeConstraint>
            </field>
          <field>
            <name>RELOAD</name>
            <description>NBYTES reload mode
This bit is set and cleared by software.</description>
            <bitOffset>24</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>RELOAD</name><usage>read-write</usage><enumeratedValue><name>Completed</name><description>The transfer is completed after the NBYTES data transfer (STOP or RESTART will follow)</description><value>0</value></enumeratedValue><enumeratedValue><name>NotCompleted</name><description>The transfer is not completed after the NBYTES data transfer (NBYTES will be reloaded)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>AUTOEND</name>
            <description>Automatic end mode (master mode)
This bit is set and cleared by software.
Note: This bit has no effect in slave mode or when the RELOAD bit is set.</description>
            <bitOffset>25</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>AUTOEND</name><usage>read-write</usage><enumeratedValue><name>Software</name><description>Software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low</description><value>0</value></enumeratedValue><enumeratedValue><name>Automatic</name><description>Automatic end mode: a STOP condition is automatically sent when NBYTES data are transferred</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>PECBYTE</name>
            <description>Packet error checking byte
This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0.
Note: Writing '0&#226;&#128;&#153; to this bit has no effect.
This bit has no effect when RELOAD is set.
This bit has no effect is slave mode when SBC=0.
If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0&#226;&#128;&#153;. Refer to .</description>
            <bitOffset>26</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>PECBYTE</name><usage>read-write</usage><enumeratedValue><name>NoPec</name><description>No PEC transfer</description><value>0</value></enumeratedValue><enumeratedValue><name>Pec</name><description>PEC transmission/reception is requested</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OAR1</name>
          <displayName>OAR1</displayName>
          <description>Own address register 1</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		   <field>
            <name>OA1</name>
            <description>Interface own slave address
7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.
10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.
Note: These bits can be written only when OA1EN=0.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>10</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>1023</maximum></range></writeConstraint>
            </field>
          <field>
            <name>OA1MODE</name>
            <description>Own Address 1 10-bit mode
Note: This bit can be written only when OA1EN=0.</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OA1MODE</name><usage>read-write</usage><enumeratedValue><name>Bit7</name><description>Own address 1 is a 7-bit address</description><value>0</value></enumeratedValue><enumeratedValue><name>Bit10</name><description>Own address 1 is a 10-bit address</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OA1EN</name>
            <description>Own Address 1 enable</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OA1EN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Own address 1 disabled. The received slave address OA1 is NACKed</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Own address 1 enabled. The received slave address OA1 is ACKed</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OAR2</name>
          <displayName>OAR2</displayName>
          <description>Own address register 2</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>OA2</name>
            <description>Interface address
7-bit addressing mode: 7-bit address
Note: These bits can be written only when OA2EN=0.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>7</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>127</maximum></range></writeConstraint>
            </field>
          <field>
            <name>OA2MSK</name>
            <description>Own Address 2 masks
Note: These bits can be written only when OA2EN=0.
As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OA2MSK</name><usage>read-write</usage><enumeratedValue><name>NoMask</name><description>No mask</description><value>0</value></enumeratedValue><enumeratedValue><name>Mask1</name><description>OA2[1] is masked and don&#8217;t care. Only OA2[7:2] are compared</description><value>1</value></enumeratedValue><enumeratedValue><name>Mask2</name><description>OA2[2:1] are masked and don&#8217;t care. Only OA2[7:3] are compared</description><value>2</value></enumeratedValue><enumeratedValue><name>Mask3</name><description>OA2[3:1] are masked and don&#8217;t care. Only OA2[7:4] are compared</description><value>3</value></enumeratedValue><enumeratedValue><name>Mask4</name><description>OA2[4:1] are masked and don&#8217;t care. Only OA2[7:5] are compared</description><value>4</value></enumeratedValue><enumeratedValue><name>Mask5</name><description>OA2[5:1] are masked and don&#8217;t care. Only OA2[7:6] are compared</description><value>5</value></enumeratedValue><enumeratedValue><name>Mask6</name><description>OA2[6:1] are masked and don&#8217;t care. Only OA2[7] is compared.</description><value>6</value></enumeratedValue><enumeratedValue><name>Mask7</name><description>OA2[7:1] are masked and don&#8217;t care. No comparison is done, and all (except reserved) 7-bit received addresses are acknowledged</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OA2EN</name>
            <description>Own Address 2 enable</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OA2EN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Own address 2 disabled. The received slave address OA2 is NACKed</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Own address 2 enabled. The received slave address OA2 is ACKed</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMINGR</name>
          <displayName>TIMINGR</displayName>
          <description>Timing register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>SCLL</name>
              <description>SCL low period (master
              mode)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>255</maximum></range></writeConstraint>
            </field>
            <field>
              <name>SCLH</name>
              <description>SCL high period (master
              mode)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>255</maximum></range></writeConstraint>
            </field>
            <field>
              <name>SDADEL</name>
              <description>Data hold time</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>15</maximum></range></writeConstraint>
            </field>
            <field>
              <name>SCLDEL</name>
              <description>Data setup time</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>15</maximum></range></writeConstraint>
            </field>
            <field>
              <name>PRESC</name>
              <description>Timing prescaler</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>15</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>TIMEOUTR</name>
          <displayName>TIMEOUTR</displayName>
          <description>Status register 1</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>TIMEOUTA</name>
            <description>Bus Timeout A
This field is used to configure:
The SCL low timeout condition tTIMEOUT when TIDLE=0
tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK
The bus idle condition (both SCL and SDA high) when TIDLE=1
tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK
Note: These bits can be written only when TIMOUTEN=0.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>12</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>4095</maximum></range></writeConstraint>
            </field>
          <field>
            <name>TIDLE</name>
            <description>Idle clock timeout detection
Note: This bit can be written only when TIMOUTEN=0.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>TIDLE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMEOUTA is used to detect SCL low timeout</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>TIMOUTEN</name>
            <description>Clock timeout enable</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>TIMOUTEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>SCL timeout detection is disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>SCL timeout detection is enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>TIMEOUTB</name>
            <description>Bus timeout B
This field is used to configure the cumulative clock extension timeout:
In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected
In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected
tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK
Note: These bits can be written only when TEXTEN=0.</description>
            <bitOffset>16</bitOffset>
            <bitWidth>12</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>4095</maximum></range></writeConstraint>
            </field>
          <field>
            <name>TEXTEN</name>
            <description>Extended clock timeout enable</description>
            <bitOffset>31</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>TEXTEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Extended clock timeout detection is disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Extended clock timeout detection is enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ISR</name>
          <displayName>ISR</displayName>
          <description>Interrupt and Status register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000001</resetValue>
          <fields>
            <field>
              <name>ADDCODE</name>
              <description>Address match code (Slave
              mode)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-only</access>
            <writeConstraint><range><minimum>0</minimum><maximum>127</maximum></range></writeConstraint>
            </field>
            <field>
            <name>DIR</name>
            <description>Transfer direction (Slave mode)
This flag is updated when an address match event occurs (ADDR=1).</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            <enumeratedValues><name>DIR</name><usage>read-write</usage><enumeratedValue><name>Write</name><description>Write transfer, slave enters receiver mode</description><value>0</value></enumeratedValue><enumeratedValue><name>Read</name><description>Read transfer, slave enters transmitter mode</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BUSY</name>
              <description>Bus busy</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>BUSY</name><usage>read-write</usage><enumeratedValue><name>NotBusy</name><description>No communication is in progress on the bus</description><value>0</value></enumeratedValue><enumeratedValue><name>Busy</name><description>A communication is in progress on the bus</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>ALERT</name>
              <description>SMBus alert</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>ALERT</name><usage>read-write</usage><enumeratedValue><name>NoAlert</name><description>SMBA alert is not detected</description><value>0</value></enumeratedValue><enumeratedValue><name>Alert</name><description>SMBA alert event is detected on SMBA pin</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Timeout or t_low detection
              flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>TIMEOUT</name><usage>read-write</usage><enumeratedValue><name>NoTimeout</name><description>No timeout occured</description><value>0</value></enumeratedValue><enumeratedValue><name>Timeout</name><description>Timeout occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>PECERR</name>
              <description>PEC Error in reception</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>PECERR</name><usage>read-write</usage><enumeratedValue><name>Match</name><description>Received PEC does match with PEC register</description><value>0</value></enumeratedValue><enumeratedValue><name>NoMatch</name><description>Received PEC does not match with PEC register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OVR</name>
              <description>Overrun/Underrun (slave
              mode)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>OVR</name><usage>read-write</usage><enumeratedValue><name>NoOverrun</name><description>No overrun/underrun error occurs</description><value>0</value></enumeratedValue><enumeratedValue><name>Overrun</name><description>slave mode with NOSTRETCH=1, when an overrun/underrun error occurs</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>ARLO</name>
              <description>Arbitration lost</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>ARLO</name><usage>read-write</usage><enumeratedValue><name>NotLost</name><description>No arbitration lost</description><value>0</value></enumeratedValue><enumeratedValue><name>Lost</name><description>Arbitration lost</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BERR</name>
              <description>Bus error</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>BERR</name><usage>read-write</usage><enumeratedValue><name>NoError</name><description>No bus error</description><value>0</value></enumeratedValue><enumeratedValue><name>Error</name><description>Misplaced Start and Stop condition is detected</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>TCR</name>
              <description>Transfer Complete Reload</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>TCR</name><usage>read-write</usage><enumeratedValue><name>NotComplete</name><description>Transfer is not complete</description><value>0</value></enumeratedValue><enumeratedValue><name>Complete</name><description>NBYTES has been transfered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>TC</name>
              <description>Transfer Complete (master
              mode)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>TC</name><usage>read-write</usage><enumeratedValue><name>NotComplete</name><description>Transfer is not complete</description><value>0</value></enumeratedValue><enumeratedValue><name>Complete</name><description>NBYTES has been transfered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>STOPF</name>
              <description>Stop detection flag</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>STOPF</name><usage>read-write</usage><enumeratedValue><name>NoStop</name><description>No Stop condition detected</description><value>0</value></enumeratedValue><enumeratedValue><name>Stop</name><description>Stop condition detected</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>NACKF</name>
              <description>Not acknowledge received
              flag</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>NACKF</name><usage>read-write</usage><enumeratedValue><name>NoNack</name><description>No NACK has been received</description><value>0</value></enumeratedValue><enumeratedValue><name>Nack</name><description>NACK has been received</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>ADDR</name>
              <description>Address matched (slave
              mode)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>ADDR</name><usage>read-write</usage><enumeratedValue><name>NotMatch</name><description>Adress mismatched or not received</description><value>0</value></enumeratedValue><enumeratedValue><name>Match</name><description>Received slave address matched with one of the enabled slave addresses</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>RXNE</name>
              <description>Receive data register not empty
              (receivers)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            <enumeratedValues><name>RXNE</name><usage>read-write</usage><enumeratedValue><name>Empty</name><description>The RXDR register is empty</description><value>0</value></enumeratedValue><enumeratedValue><name>NotEmpty</name><description>Received data is copied into the RXDR register, and is ready to be read</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>TXIS</name>
              <description>Transmit interrupt status
              (transmitters)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            <enumeratedValues><name>TXIS</name><usage>read-write</usage><enumeratedValue><name>NotEmpty</name><description>The TXDR register is not empty</description><value>0</value></enumeratedValue><enumeratedValue><name>Empty</name><description>The TXDR register is empty and the data to be transmitted must be written in the TXDR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>TXE</name>
              <description>Transmit data register empty
              (transmitters)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            <enumeratedValues><name>TXE</name><usage>read-write</usage><enumeratedValue><name>NotEmpty</name><description>TXDR register not empty</description><value>0</value></enumeratedValue><enumeratedValue><name>Empty</name><description>TXDR register empty</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt clear register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ALERTCF</name>
              <description>Alert flag clear</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>ALERTCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the ALERT flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>TIMOUTCF</name>
              <description>Timeout detection flag
              clear</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>TIMOUTCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the TIMOUT flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>PECCF</name>
              <description>PEC Error flag clear</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>PECCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the PEC flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OVRCF</name>
              <description>Overrun/Underrun flag
              clear</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>OVRCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the OVR flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>ARLOCF</name>
              <description>Arbitration lost flag
              clear</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>ARLOCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the ARLO flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>BERRCF</name>
              <description>Bus error flag clear</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>BERRCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the BERR flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>STOPCF</name>
              <description>Stop detection flag clear</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>STOPCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the STOP flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>NACKCF</name>
              <description>Not Acknowledge flag clear</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>NACKCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the NACK flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>ADDRCF</name>
              <description>Address Matched flag clear</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>ADDRCF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the ADDR flag in ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PECR</name>
          <displayName>PECR</displayName>
          <description>PEC register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>PEC</name>
              <description>Packet error checking
              register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>255</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>RXDR</name>
          <displayName>RXDR</displayName>
          <description>Receive data register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>RXDATA</name>
              <description>8-bit receive data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>255</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>TXDR</name>
          <displayName>TXDR</displayName>
          <description>Transmit data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>TXDATA</name>
              <description>8-bit transmit data</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>255</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2C1">
      <name>I2C2</name>
      <baseAddress>0x40005800</baseAddress>
      <interrupt>
        <name>I2C2</name>
        <description>I2C2 global interrupt</description>
        <value>24</value>
      </interrupt>
    </peripheral>
    <peripheral>
      <name>IWDG</name>
      <description>Independent watchdog</description>
      <groupName>IWDG</groupName>
      <baseAddress>0x40003000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>KR</name>
          <displayName>KR</displayName>
          <description>Key register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>KEY</name>
              <description>Key value (write only, read
              0x0000)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <enumeratedValues><name>KEY</name><usage>read-write</usage><enumeratedValue><name>Enable</name><description>Enable access to PR, RLR and WINR registers (0x5555)</description><value>21845</value></enumeratedValue><enumeratedValue><name>Reset</name><description>Reset the watchdog value (0xAAAA)</description><value>43690</value></enumeratedValue><enumeratedValue><name>Start</name><description>Start the watchdog (0xCCCC)</description><value>52428</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>PR</name>
          <displayName>PR</displayName>
          <description>Prescaler register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
            <name>PR</name>
            <description>Prescaler divider
These bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the  must be reset in order to be able to change the prescaler divider.
Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>PR</name><usage>read-write</usage><enumeratedValue><name>DivideBy4</name><description>Divider /4</description><value>0</value></enumeratedValue><enumeratedValue><name>DivideBy8</name><description>Divider /8</description><value>1</value></enumeratedValue><enumeratedValue><name>DivideBy16</name><description>Divider /16</description><value>2</value></enumeratedValue><enumeratedValue><name>DivideBy32</name><description>Divider /32</description><value>3</value></enumeratedValue><enumeratedValue><name>DivideBy64</name><description>Divider /64</description><value>4</value></enumeratedValue><enumeratedValue><name>DivideBy128</name><description>Divider /128</description><value>5</value></enumeratedValue><enumeratedValue><name>DivideBy256</name><description>Divider /256</description><value>6</value></enumeratedValue><enumeratedValue><name>DivideBy256bis</name><description>Divider /256</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RLR</name>
          <displayName>RLR</displayName>
          <description>Reload register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000FFF</resetValue>
          <fields>
            <field>
              <name>RL</name>
              <description>Watchdog counter reload
              value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>4095</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>PVU</name>
            <description>Watchdog prescaler value update
This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles).
Prescaler value can be updated only when PVU bit is reset.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>RVU</name>
            <description>Watchdog counter reload value update
This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).
Reload value can be updated only when RVU bit is reset.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>WVU</name>
            <description>Watchdog counter window value update
This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).
Window value can be updated only when WVU bit is reset.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          </fields>
        </register>
        <register>
          <name>WINR</name>
          <displayName>WINR</displayName>
          <description>Window register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000FFF</resetValue>
          <fields>
            <field>
              <name>WIN</name>
              <description>Watchdog counter window
              value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>12</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>4095</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
	<peripheral>
      <name>TIM1</name>
      <description>Advanced-timers</description>
      <groupName>TIM</groupName>
      <baseAddress>0x40012C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM1_BRK_UP_TRG_COM</name>
        <description>TIM1 break, update, trigger and commutation interrupts</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>TIM1_CC</name>
        <description>TIM1 Capture Compare interrupt</description>
        <value>14</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>CEN</name>
            <description>Counter enable
Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDIS</name>
            <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDIS</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Update event enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Update event disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>URS</name>
            <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>URS</name><usage>read-write</usage><enumeratedValue><name>AnyEvent</name><description>Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request</description><value>0</value></enumeratedValue><enumeratedValue><name>CounterOnly</name><description>Only counter overflow/underflow generates an update interrupt or DMA request</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OPM</name>
            <description>One pulse mode</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OPM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter is not stopped at update event</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter stops counting at the next update event (clearing the CEN bit)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>DIR</name>
            <description>Direction
Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>DIR</name><usage>read-write</usage><enumeratedValue><name>Up</name><description>Counter used as upcounter</description><value>0</value></enumeratedValue><enumeratedValue><name>Down</name><description>Counter used as downcounter</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CMS</name>
            <description>Center-aligned mode selection
Note: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed</description>
            <bitOffset>5</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CMS</name><usage>read-write</usage><enumeratedValue><name>EdgeAligned</name><description>The counter counts up or down depending on the direction bit</description><value>0</value></enumeratedValue><enumeratedValue><name>CenterAligned1</name><description>The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.</description><value>1</value></enumeratedValue><enumeratedValue><name>CenterAligned2</name><description>The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.</description><value>2</value></enumeratedValue><enumeratedValue><name>CenterAligned3</name><description>The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ARPE</name>
            <description>Auto-reload preload enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ARPE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMx_APRR register is not buffered</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMx_APRR register is buffered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CKD</name>
            <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (ETR, TIx):
Note: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CKD</name><usage>read-write</usage><enumeratedValue><name>Div1</name><description>t_DTS = t_CK_INT</description><value>0</value></enumeratedValue><enumeratedValue><name>Div2</name><description>t_DTS = 2 &#215; t_CK_INT</description><value>1</value></enumeratedValue><enumeratedValue><name>Div4</name><description>t_DTS = 4 &#215; t_CK_INT</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UIFREMAP</name>
            <description>UIF status bit remapping</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>CCPC</name>
            <description>Capture/compare preloaded control
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CCUS</name>
            <description>Capture/compare control update selection
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CCDS</name>
            <description>Capture/compare DMA selection</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MMS</name>
            <description>Master mode selection
These bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI1S</name>
            <description>TI1 selection</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS1</name>
            <description>Output Idle state 1 (OC1 output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS1N</name>
            <description>Output Idle state 1 (OC1N output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS2</name>
            <description>Output Idle state 2 (OC2 output)
Refer to OIS1 bit</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIS2N</name>
            <description>Output Idle state 2 (OC2N output)
Refer to OIS1N bit</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIS3</name>
            <description>Output Idle state 3 (OC3 output)
Refer to OIS1 bit</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIS3N</name>
            <description>Output Idle state 3 (OC3N output)
Refer to OIS1N bit</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIS4</name>
            <description>Output Idle state 4 (OC4 output)
Refer to OIS1 bit</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIS5</name>
            <description>Output Idle state 5 (OC5 output)
Refer to OIS1 bit</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>OIS6</name>
            <description>Output Idle state 6 (OC6 output)
Refer to OIS1 bit</description>
            <bitOffset>18</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>MMS2</name>
            <description>Master mode selection 2
These bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows:
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>20</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>slave mode control register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>SMS1</name>
            <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>0</bitOffset>
          
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OCCS</name>
            <description>OCREF clear selection
This bit is used to select the OCREF clear source.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TS1</name>
            <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
            <bitOffset>4</bitOffset>
      
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MSM</name>
            <description>Master/slave mode</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETF</name>
            <description>External trigger filter
This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
            <bitOffset>8</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETPS</name>
            <description>External trigger prescaler
External trigger signal ETRP frequency must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ECE</name>
            <description>External clock enable
This bit enables External clock mode 2.
Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).
It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).
If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETP</name>
            <description>External trigger polarity
This bit selects whether ETR or ETR is used for trigger operations</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>SMS2</name>
            <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>16</bitOffset>
          
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TS2</name>
            <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
            <bitOffset>20</bitOffset>
       
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>DMA/Interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UIE</name>
            <description>Update interrupt enable</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IE</name>
            <description>Capture/Compare 1 interrupt enable</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2IE</name>
            <description>Capture/Compare 2 interrupt enable</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC3IE</name>
            <description>Capture/Compare 3 interrupt enable</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC4IE</name>
            <description>Capture/Compare 4 interrupt enable</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>COMIE</name>
            <description>COM interrupt enable</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TIE</name>
            <description>Trigger interrupt enable</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BIE</name>
            <description>Break interrupt enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>UDE</name>
            <description>Update DMA request enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1DE</name>
            <description>Capture/Compare 1 DMA request enable</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2DE</name>
            <description>Capture/Compare 2 DMA request enable</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC3DE</name>
            <description>Capture/Compare 3 DMA request enable</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC4DE</name>
            <description>Capture/Compare 4 DMA request enable</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>COMDE</name>
            <description>COM DMA request enable</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TDE</name>
            <description>Trigger DMA request enable</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UIF</name>
            <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>No update occurred</description><value>0</value></enumeratedValue><enumeratedValue><name>UpdatePending</name><description>Update interrupt pending.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IF</name>
            <description>Capture/Compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2IF</name>
            <description>Capture/Compare 2 interrupt flag
Refer to CC1IF description</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC3IF</name>
            <description>Capture/Compare 3 interrupt flag
Refer to CC1IF description</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC4IF</name>
            <description>Capture/Compare 4 interrupt flag
Refer to CC1IF description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>COMIF</name>
            <description>COM interrupt flag
This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TIF</name>
            <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BIF</name>
            <description>Break interrupt flag
This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>B2IF</name>
            <description>Break 2 interrupt flag
This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1OF</name>
            <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0&#226;&#128;&#153;.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2OF</name>
            <description>Capture/Compare 2 overcapture flag
Refer to CC1OF description</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC3OF</name>
            <description>Capture/Compare 3 overcapture flag
Refer to CC1OF description</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC4OF</name>
            <description>Capture/Compare 4 overcapture flag
Refer to CC1OF description</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>SBIF</name>
            <description>System Break interrupt flag
This flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.
This flag must be reset to re-start PWM operation.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC5IF</name>
            <description>Compare 5 interrupt flag
Refer to CC1IF description (Note: Channel 5 can only be configured as output)</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC6IF</name>
            <description>Compare 6 interrupt flag
Refer to CC1IF description (Note: Channel 6 can only be configured as output)</description>
            <bitOffset>17</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UG</name>
            <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            <enumeratedValues><name>UG</name><usage>read-write</usage><enumeratedValue><name>Update</name><description>Re-initializes the timer counter and generates an update of the registers.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1G</name>
            <description>Capture/Compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>CC2G</name>
            <description>Capture/Compare 2 generation
Refer to CC1G description</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CC3G</name>
            <description>Capture/Compare 3 generation
Refer to CC1G description</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CC4G</name>
            <description>Capture/Compare 4 generation
Refer to CC1G description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>COMG</name>
            <description>Capture/Compare control update generation
This bit can be set by software, it is automatically cleared by hardware
Note: This bit acts only on channels having a complementary output.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>TG</name>
            <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>BG</name>
            <description>Break generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>B2G</name>
            <description>Break 2 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Output</name>
          <displayName>CCMR1_Output</displayName>
          <description>capture/compare mode register 1 (output
          mode)</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		    <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1FE</name>
                <description>Output Compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1PE</name>
                <description>Output Compare 1 preload enable
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1M1</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1CE</name>
                <description>Output Compare 1 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC2FE</name>
                <description>Output Compare 2 fast enable
Refer to OC1FE description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2PE</name>
                <description>Output Compare 2 preload enable
Refer to OC1PE description.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2M</name>
                <description>Output Compare 2 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>12</bitOffset>

                <bitWidth>3</bitWidth>
                <access>read-write</access>
              <enumeratedValues><name>OC2M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
              <field>
                <name>OC2CE</name>
                <description>Output Compare 2 clear enable
Refer to OC1CE description.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC1M2</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
Note: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
          
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>              
              <field>
                <name>OC2M_3</name>
                <description>Output Compare 2 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>24</bitOffset>
          
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              <enumeratedValues><name>OC2M_3</name><usage>read-write</usage><enumeratedValue><name>Normal</name><description>Normal output compare mode (modes 0-7)</description><value>0</value></enumeratedValue><enumeratedValue><name>Extended</name><description>Extended output compare mode (modes 7-15)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Input</name>
          <displayName>CCMR1_Input</displayName>
          <description>capture/compare mode register 1 (output
          mode)</description>
          <alternateRegister>CCMR1_Output</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>CC1S</name>
            <description>Capture/Compare 1 Selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1PSC</name>
            <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=&#226;&#128;&#153;0&#226;&#128;&#153; (TIMx_CCER register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1F</name>
            <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
            <bitOffset>4</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2S</name>
            <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC2PSC</name>
            <description>Input capture 2 prescaler
Refer to IC1PSC[1:0] description.</description>
            <bitOffset>10</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>IC2F</name>
            <description>Input capture 2 filter
Refer to IC1F[3:0] description.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCMR2_Output</name>
          <displayName>CCMR2_Output</displayName>
          <description>capture/compare mode register 2 (output
          mode)</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		    <field>
                <name>CC3S</name>
                <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC3FE</name>
                <description>Output compare 3 fast enable
Refer to OC1FE description.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3PE</name>
                <description>Output compare 3 preload enable
Refer to OC1PE description.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M</name>
                <description>Output compare 3 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>4</bitOffset>
        
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              <enumeratedValues><name>OC3M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
              <field>
                <name>OC3CE</name>
                <description>Output compare 3 clear enable
Refer to OC1CE description.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>CC4S</name>
                <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC4FE</name>
                <description>Output compare 4 fast enable
Refer to OC1FE description.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4PE</name>
                <description>Output compare 4 preload enable
Refer to OC1PE description.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC4M</name>
                <description>Output compare 4 mode
Refer to OC3M[3:0] description.</description>
                <bitOffset>12</bitOffset>
          
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              <enumeratedValues derivedFrom="OC3M"/>
            </field>
              <field>
                <name>OC4CE</name>
                <description>Output compare 4 clear enable
Refer to OC1CE description.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC3M_3</name>
                <description>Output compare 3 mode
Refer to OC1M[3:0] description.</description>
                <bitOffset>16</bitOffset>

                <bitWidth>1</bitWidth>
                <access>read-write</access>
              <enumeratedValues><name>OC3M_3</name><usage>read-write</usage><enumeratedValue><name>Normal</name><description>Normal output compare mode (modes 0-7)</description><value>0</value></enumeratedValue><enumeratedValue><name>Extended</name><description>Extended output compare mode (modes 7-15)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>            
              <field>
                <name>OC4M_3</name>
                <description>Output compare 4 mode
Refer to OC3M[3:0] description.</description>
                <bitOffset>24</bitOffset>
          
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              <enumeratedValues derivedFrom="OC3M_3"/>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2_Input</name>
          <displayName>CCMR2_Input</displayName>
          <description>capture/compare mode register 2 (output
          mode)</description>
          <alternateRegister>CCMR2_Output</alternateRegister>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
           <field>
            <name>CC3S</name>
            <description>Capture/compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC3PSC</name>
            <description>Input capture 3 prescaler
Refer to IC1PSC[1:0] description.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>IC3F</name>
            <description>Input capture 3 filter
Refer to IC1F[3:0] description.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4S</name>
            <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC4PSC</name>
            <description>Input capture 4 prescaler
Refer to IC1PSC[1:0] description.</description>
            <bitOffset>10</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>IC4F</name>
            <description>Input capture 4 filter
Refer to IC1F[3:0] description.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>capture/compare enable
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>CC1E</name>
            <description>Capture/Compare 1 output enable
When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.
Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1P</name>
            <description>Capture/Compare 1 output polarity
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	The configuration is reserved, it must not be used.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NE</name>
            <description>Capture/Compare 1 complementary output enable
On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NP</name>
            <description>Capture/Compare 1 complementary output polarity
CC1 channel configured as output:
CC1 channel configured as input:
This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#157;00&#226;&#128;&#157; (channel configured as output).
On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2E</name>
            <description>Capture/Compare 2 output enable
Refer to CC1E description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2P</name>
            <description>Capture/Compare 2 output polarity
Refer to CC1P description</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2NE</name>
            <description>Capture/Compare 2 complementary output enable
Refer to CC1NE description</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2NP</name>
            <description>Capture/Compare 2 complementary output polarity
Refer to CC1NP description</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3E</name>
            <description>Capture/Compare 3 output enable
Refer to CC1E description</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3P</name>
            <description>Capture/Compare 3 output polarity
Refer to CC1P description</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3NE</name>
            <description>Capture/Compare 3 complementary output enable
Refer to CC1NE description</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3NP</name>
            <description>Capture/Compare 3 complementary output polarity
Refer to CC1NP description</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4E</name>
            <description>Capture/Compare 4 output enable
Refer to CC1E description</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4P</name>
            <description>Capture/Compare 4 output polarity
Refer to CC1P description</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4NP</name>
            <description>Capture/Compare 4 complementary output polarity
Refer to CC1NP description</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC5E</name>
            <description>Capture/Compare 5 output enable
Refer to CC1E description</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC5P</name>
            <description>Capture/Compare 5 output polarity
Refer to CC1P description</description>
            <bitOffset>17</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC6E</name>
            <description>Capture/Compare 6 output enable
Refer to CC1E description</description>
            <bitOffset>20</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC6P</name>
            <description>Capture/Compare 6 output polarity
Refer to CC1P description</description>
            <bitOffset>21</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>CNT</name>
            <description>Counter value</description>
            <bitOffset>0</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          <field>
            <name>UIFCPY</name>
            <description>UIF copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.</description>
            <bitOffset>31</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
          <field>
            <name>PSC</name>
            <description>Prescaler value
The counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1).
PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in &#226;&#128;&#156;reset mode&#226;&#128;&#157;).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <fields>
          <field>
            <name>ARR</name>
            <description>Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>REP</name>
              <description>Repetition counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>capture/compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Capture/Compare 1 value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>capture/compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR2</name>
              <description>Capture/Compare 2 value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>capture/compare register 3</description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR3</name>
              <description>Capture/Compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>capture/compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR4</name>
              <description>Capture/Compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>BDTR</name>
          <displayName>BDTR</displayName>
          <description>break and dead-time register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>DTG</name>
            <description>Dead-time generator setup
This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.
DTG[7:5]=0xx =&gt; DT=DTG[7:0]x tDTG with tDTG=tDTS.
DTG[7:5]=10x =&gt; DT=(64+DTG[5:0])xtDTG with tDTG=2xtDTS.
DTG[7:5]=110 =&gt; DT=(32+DTG[4:0])xtDTG with tDTG=8xtDTS.
DTG[7:5]=111 =&gt; DT=(32+DTG[4:0])xtDTG with tDTG=16xtDTS.
Example if tDTS=125&#194;&#160;ns (8&#194;&#160;MHz), dead-time possible values are:
0 to 15875&#194;&#160;ns by 125&#194;&#160;ns steps,
16&#194;&#160;&#206;&#188;s to 31750&#194;&#160;ns&#194;&#160; by 250&#194;&#160;ns steps,
32&#194;&#160;&#206;&#188;s to 63&#194;&#160;&#206;&#188;s by 1&#194;&#160;&#206;&#188;s steps,
64&#194;&#160;&#206;&#188;s to 126&#194;&#160;&#206;&#188;s by 2&#194;&#160;&#206;&#188;s steps
Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>LOCK</name>
            <description>Lock configuration
These bits offer a write protection against software errors.
Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OSSI</name>
            <description>Off-state selection for Idle mode
This bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.
See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OSSI</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>When inactive, OC/OCN outputs are disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>IdleLevel</name><description>When inactive, OC/OCN outputs are forced to idle level</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OSSR</name>
            <description>Off-state selection for Run mode
This bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OSSR</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>When inactive, OC/OCN outputs are disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>IdleLevel</name><description>When inactive, OC/OCN outputs are enabled with their inactive level</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>BKE</name>
            <description>Break enable
This bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per ).
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKP</name>
            <description>Break polarity
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>AOE</name>
            <description>Automatic output enable
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MOE</name>
            <description>Main output enable
This bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
In response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.
See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>MOE</name><usage>read-write</usage><enumeratedValue><name>DisabledIdle</name><description>OC/OCN are disabled or forced idle depending on OSSI</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>OC/OCN are enabled if CCxE/CCxNE are set</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>BKF</name>
            <description>Break filter
This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>16</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2F</name>
            <description>Break 2 filter
This bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>20</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2E</name>
            <description>Break 2 enable
Note: The BRK2 must only be used with OSSR = OSSI = 1.
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>24</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2P</name>
            <description>Break 2 polarity
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>25</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKDSRM</name>
            <description>Break Disarm
This bit is cleared by hardware when no break source is active.
The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>26</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2DSRM</name>
            <description>Break2 Disarm
Refer to BKDSRM description</description>
            <bitOffset>27</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>BKBID</name>
            <description>Break Bidirectional
In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>28</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2BID</name>
            <description>Break2 bidirectional
Refer to BKBID description</description>
            <bitOffset>29</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>DMA control register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>DBA</name>
            <description>DMA base address
This 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DBL</name>
            <description>DMA burst length
This 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...
Example: Let us consider the following transfer: DBL = 7 bytes &amp; DBA = TIMx_CR1.
If DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:
(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL
In this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA
According to the configuration of the DMA Data Size, several cases may occur:
If the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers.
If the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAR</name>
          <displayName>DMAR</displayName>
          <description>DMA address for full transfer</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
			 <field>
				<name>DMAB</name>
				<description>DMA register for burst accesses
	A read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4
	where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).</description>
				<bitOffset>0</bitOffset>
				<bitWidth>32</bitWidth>
				<access>read-write</access>
			 </field>
          </fields>
        </register>
        <register>
          <name>OR1</name>
          <displayName>OR1</displayName>
          <description>option register 1</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>OCREF_CLR</name>
            <description>Ocref_clr source selection
This bit selects the ocref_clr input source.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR3_Output</name>
          <displayName>CCMR3_Output</displayName>
          <description>capture/compare mode register 2 (output
          mode)</description>
          <addressOffset>0x54</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC6M_3</name>
              <description>Output Compare 6 mode bit
              3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OC5M_3"/>
            </field>
            <field>
              <name>OC5M_3</name>
              <description>Output Compare 5 mode bit
              3</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>OC5M_3</name><usage>read-write</usage><enumeratedValue><name>Normal</name><description>Normal output compare mode (modes 0-7)</description><value>0</value></enumeratedValue><enumeratedValue><name>Extended</name><description>Extended output compare mode (modes 7-15)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OC6CE</name>
              <description>Output compare 6 clear
              enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC6M</name>
              <description>Output compare 6 mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            <enumeratedValues derivedFrom="OC5M"/>
            </field>
            <field>
              <name>OC6PE</name>
              <description>Output compare 6 preload
              enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC6FE</name>
              <description>Output compare 6 fast
              enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC5CE</name>
              <description>Output compare 5 clear
              enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC5M</name>
              <description>Output compare 5 mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            <enumeratedValues><name>OC5M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OC5PE</name>
              <description>Output compare 5 preload
              enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC5FE</name>
              <description>Output compare 5 fast
              enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR5</name>
          <displayName>CCR5</displayName>
          <description>capture/compare register 4</description>
          <addressOffset>0x58</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		   <field>
            <name>CCR5</name>
            <description>Capture/Compare 5 value
CCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>GC5C1</name>
            <description>Group Channel 5 and Channel 1
Distortion on Channel 1 output:
This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
Note: it is also possible to apply this distortion on combined PWM signals.</description>
            <bitOffset>29</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GC5C2</name>
            <description>Group Channel 5 and Channel 2
Distortion on Channel 2 output:
This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).
Note: it is also possible to apply this distortion on combined PWM signals.</description>
            <bitOffset>30</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GC5C3</name>
            <description>Group Channel 5 and Channel 3
Distortion on Channel 3 output:
This bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).
Note: it is also possible to apply this distortion on combined PWM signals.</description>
            <bitOffset>31</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR6</name>
          <displayName>CCR6</displayName>
          <description>capture/compare register 4</description>
          <addressOffset>0x5C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR6</name>
              <description>Capture/Compare value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AF1</name>
          <displayName>AF1</displayName>
          <description>DMA address for full transfer</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
		  <field>
            <name>BKINE</name>
            <description>BRK BKIN input enable
This bit enables the BKIN alternate function input for the timer&#226;&#128;&#153;s BRK input. BKIN input is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP1E</name>
            <description>BRK COMP1 enable
This bit enables the COMP1 for the timer&#226;&#128;&#153;s BRK input. COMP1 output is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP2E</name>
            <description>BRK COMP2 enable
This bit enables the COMP2 for the timer&#226;&#128;&#153;s BRK input. COMP2 output is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKINP</name>
            <description>BRK BKIN input polarity
This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP1P</name>
            <description>BRK COMP1 input polarity
This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP2P</name>
            <description>BRK COMP2 input polarity
This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETRSEL</name>
            <description>ETR source selection
These bits select the ETR input source.
Others: Reserved
Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>14</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AF2</name>
          <displayName>AF2</displayName>
          <description>DMA address for full transfer</description>
          <addressOffset>0x64</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
		  <field>
            <name>BK2INE</name>
            <description>BRK2 BKIN input enable
This bit enables the BKIN2 alternate function input for the timer&#226;&#128;&#153;s BRK2 input. BKIN2 input is 'ORed&#226;&#128;&#153; with the other BRK2 sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2CMP1E</name>
            <description>BRK2 COMP1 enable
This bit enables the COMP1 for the timer&#226;&#128;&#153;s BRK2 input. COMP1 output is 'ORed&#226;&#128;&#153; with the other BRK2 sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2CMP2E</name>
            <description>BRK2 COMP2 enable
This bit enables the COMP2 for the timer&#226;&#128;&#153;s BRK2 input. COMP2 output is 'ORed&#226;&#128;&#153; with the other BRK2 sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2INP</name>
            <description>BRK2 BKIN2 input polarity
This bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2CMP1P</name>
            <description>BRK2 COMP1 input polarity
This bit selects the COMP1 input sensitivity. It must be programmed together with the BK2P polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BK2CMP2P</name>
            <description>BRK2 COMP2 input polarity
This bit selects the COMP2 input sensitivity. It must be programmed together with the BK2P polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TISEL</name>
          <displayName>TISEL</displayName>
          <description>TIM1 timer input selection
          register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>TI1SEL</name>
            <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
            <bitOffset>0</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI2SEL</name>
            <description>selects TI2[0] to TI2[15] input
Others: Reserved</description>
            <bitOffset>8</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI3SEL</name>
            <description>selects TI3[0] to TI3[15] input
Others: Reserved</description>
            <bitOffset>16</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI4SEL</name>
            <description>selects TI4[0] to TI4[15] input
Others: Reserved</description>
            <bitOffset>24</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIM3</name>
	  <description>General-purpose-timers</description>
      <groupName>TIM</groupName>
      <baseAddress>0x40000400</baseAddress>
	  <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
	  <interrupt>
        <name>TIM3</name>
        <description>TIM3 global interrupt</description>
        <value>16</value>
      </interrupt>
	  <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CEN</name>
            <description>Counter enable
Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDIS</name>
            <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDIS</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Update event enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Update event disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>URS</name>
            <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>URS</name><usage>read-write</usage><enumeratedValue><name>AnyEvent</name><description>Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request</description><value>0</value></enumeratedValue><enumeratedValue><name>CounterOnly</name><description>Only counter overflow/underflow generates an update interrupt or DMA request</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OPM</name>
            <description>One-pulse mode</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OPM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter is not stopped at update event</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter stops counting at the next update event (clearing the CEN bit)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>DIR</name>
            <description>Direction
Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>DIR</name><usage>read-write</usage><enumeratedValue><name>Up</name><description>Counter used as upcounter</description><value>0</value></enumeratedValue><enumeratedValue><name>Down</name><description>Counter used as downcounter</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CMS</name>
            <description>Center-aligned mode selection
Note: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)</description>
            <bitOffset>5</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CMS</name><usage>read-write</usage><enumeratedValue><name>EdgeAligned</name><description>The counter counts up or down depending on the direction bit</description><value>0</value></enumeratedValue><enumeratedValue><name>CenterAligned1</name><description>The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.</description><value>1</value></enumeratedValue><enumeratedValue><name>CenterAligned2</name><description>The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.</description><value>2</value></enumeratedValue><enumeratedValue><name>CenterAligned3</name><description>The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ARPE</name>
            <description>Auto-reload preload enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ARPE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMx_APRR register is not buffered</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMx_APRR register is buffered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CKD</name>
            <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CKD</name><usage>read-write</usage><enumeratedValue><name>Div1</name><description>t_DTS = t_CK_INT</description><value>0</value></enumeratedValue><enumeratedValue><name>Div2</name><description>t_DTS = 2 &#215; t_CK_INT</description><value>1</value></enumeratedValue><enumeratedValue><name>Div4</name><description>t_DTS = 4 &#215; t_CK_INT</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UIFREMAP</name>
            <description>UIF status bit remapping</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CCDS</name>
            <description>Capture/compare DMA selection</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MMS</name>
            <description>Master mode selection
These bits permit to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI1S</name>
            <description>TI1 selection</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>slave mode control register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>SMS1</name>
            <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
reinitializes the counter, generates an update of the registers and starts the counter.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>0</bitOffset>
          
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OCCS</name>
            <description>OCREF clear selection
This bit is used to select the OCREF clear source</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TS1</name>
            <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
            <bitOffset>4</bitOffset>
       
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MSM</name>
            <description>Master/Slave mode</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETF</name>
            <description>External trigger filter
This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
            <bitOffset>8</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETPS</name>
            <description>External trigger prescaler
External trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ECE</name>
            <description>External clock enable
This bit enables External clock mode 2.
Note: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).
It is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).
If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ETP</name>
            <description>External trigger polarity
This bit selects whether ETR or ETR is used for trigger operations</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>SMS2</name>
            <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
reinitializes the counter, generates an update of the registers and starts the counter.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>16</bitOffset>
          
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TS2</name>
            <description>Trigger selection
This bit-field selects the trigger input to be used to synchronize the counter.
Others: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
            <bitOffset>20</bitOffset>
        
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>DMA/Interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UIE</name>
            <description>Update interrupt enable</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IE</name>
            <description>Capture/Compare 1 interrupt enable</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2IE</name>
            <description>Capture/Compare 2 interrupt enable</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC3IE</name>
            <description>Capture/Compare 3 interrupt enable</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC4IE</name>
            <description>Capture/Compare 4 interrupt enable</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TIE</name>
            <description>Trigger interrupt enable</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>UDE</name>
            <description>Update DMA request enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1DE</name>
            <description>Capture/Compare 1 DMA request enable</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2DE</name>
            <description>Capture/Compare 2 DMA request enable</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC3DE</name>
            <description>Capture/Compare 3 DMA request enable</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC4DE</name>
            <description>Capture/Compare 4 DMA request enable</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TDE</name>
            <description>Trigger DMA request enable</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UIF</name>
            <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow and if UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>No update occurred</description><value>0</value></enumeratedValue><enumeratedValue><name>UpdatePending</name><description>Update interrupt pending.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IF</name>
            <description>Capture/compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2IF</name>
            <description>Capture/Compare 2 interrupt flag
Refer to CC1IF description</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC3IF</name>
            <description>Capture/Compare 3 interrupt flag
Refer to CC1IF description</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC4IF</name>
            <description>Capture/Compare 4 interrupt flag
Refer to CC1IF description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>TIF</name>
            <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1OF</name>
            <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0&#226;&#128;&#153;.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2OF</name>
            <description>Capture/compare 2 overcapture flag
refer to CC1OF description</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC3OF</name>
            <description>Capture/Compare 3 overcapture flag
refer to CC1OF description</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>CC4OF</name>
            <description>Capture/Compare 4 overcapture flag
refer to CC1OF description</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UG</name>
            <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            <enumeratedValues><name>UG</name><usage>read-write</usage><enumeratedValue><name>Update</name><description>Re-initializes the timer counter and generates an update of the registers.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1G</name>
            <description>Capture/compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>CC2G</name>
            <description>Capture/compare 2 generation
Refer to CC1G description</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CC3G</name>
            <description>Capture/compare 3 generation
Refer to CC1G description</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CC4G</name>
            <description>Capture/compare 4 generation
Refer to CC1G description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>TG</name>
            <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Output</name>
          <displayName>CCMR1_Output</displayName>
          <description>capture/compare mode register 1 (output
          mode)</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC2M_3</name>
              <description>Output Compare 2 mode - bit
              3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OC1M_3"/>
            </field>
            <field>
              <name>OC1M_3</name>
              <description>Output Compare 1 mode - bit
              3</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>OC1M_3</name><usage>read-write</usage><enumeratedValue><name>Normal</name><description>Normal output compare mode (modes 0-7)</description><value>0</value></enumeratedValue><enumeratedValue><name>Extended</name><description>Extended output compare mode (modes 7-15)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OC2CE</name>
              <description>Output compare 2 clear
              enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC2M</name>
              <description>Output compare 2 mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            <enumeratedValues derivedFrom="OC1M"/>
            </field>
            <field>
              <name>OC2PE</name>
              <description>Output compare 2 preload
              enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC2FE</name>
              <description>Output compare 2 fast
              enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
            <name>CC2S</name>
            <description>Capture/compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
            <field>
                <name>OC1CE</name>
                <description>Output compare 1 clear enable</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
            <field>
                <name>OC1M</name>
                <description>Output compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
              
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues><name>OC1M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
                <name>OC1PE</name>
                <description>Output compare 1 preload enable
Note: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
            <field>
              <name>OC1FE</name>
              <description>Output compare 1 fast
              enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
            <name>CC1S</name>
            <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Input</name>
          <displayName>CCMR1_Input</displayName>
          <description>capture/compare mode register 1 (input
          mode)</description>
          <alternateRegister>CCMR1_Output</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IC2F</name>
              <description>Input capture 2 filter</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC2PSC</name>
              <description>Input capture 2 prescaler</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC2S</name>
              <description>Capture/compare 2
              selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>IC1F</name>
              <description>Input capture 1 filter</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC1PSC</name>
              <description>Input capture 1 prescaler</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>CC1S</name>
              <description>Capture/Compare 1
              selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2_Output</name>
          <displayName>CCMR2_Output</displayName>
          <description>capture/compare mode register 2 (output
          mode)</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>OC4M_3</name>
              <description>Output Compare 4 mode - bit
              3</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues derivedFrom="OC3M_3"/>
            </field>
            <field>
              <name>OC3M_3</name>
              <description>Output Compare 3 mode - bit
              3</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>OC3M_3</name><usage>read-write</usage><enumeratedValue><name>Normal</name><description>Normal output compare mode (modes 0-7)</description><value>0</value></enumeratedValue><enumeratedValue><name>Extended</name><description>Extended output compare mode (modes 7-15)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OC4CE</name>
              <description>Output compare 4 clear
              enable</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC4M</name>
              <description>Output compare 4 mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
            <enumeratedValues derivedFrom="OC3M"/>
            </field>
            <field>
              <name>OC4PE</name>
              <description>Output compare 4 preload
              enable</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC4FE</name>
              <description>Output compare 4 fast
              enable</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC4S</name>
              <description>Capture/Compare 4
              selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
              <name>OC3CE</name>
              <description>Output compare 3 clear
              enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3M</name>
              <description>Output compare 3 mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
            <enumeratedValues><name>OC3M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active / AsymmetricPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC outputs OC1REF when the counter is counting up, OC2REF when it is counting down</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1 / AsymmetricPwmMode2: Inversely to AsymmetricPwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
            <field>
              <name>OC3PE</name>
              <description>Output compare 3 preload
              enable</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>OC3FE</name>
              <description>Output compare 3 fast
              enable</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
            <field>
              <name>CC3S</name>
              <description>Capture/Compare 3
              selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR2_Input</name>
          <displayName>CCMR2_Input</displayName>
          <description>capture/compare mode register 2 (input
          mode)</description>
          <alternateRegister>CCMR2_Output</alternateRegister>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>IC4F</name>
              <description>Input capture 4 filter</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC4PSC</name>
              <description>Input capture 4 prescaler</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
             <field>
            <name>CC4S</name>
            <description>Capture/Compare 4 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
            <field>
              <name>IC3F</name>
              <description>Input capture 3 filter</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
            </field>
            <field>
              <name>IC3PSC</name>
              <description>Input capture 3 prescaler</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
            </field>
            <field>
            <name>CC3S</name>
            <description>Capture/Compare 3 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>capture/compare enable
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CC1E</name>
            <description>Capture/Compare 1 output enable.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1P</name>
            <description>Capture/Compare 1 output Polarity.
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	This configuration is reserved, it must not be used.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NP</name>
            <description>Capture/Compare 1 output Polarity.
CC1 channel configured as output: CC1NP must be kept cleared in this case.
CC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2E</name>
            <description>Capture/Compare 2 output enable.
Refer to CC1E description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2P</name>
            <description>Capture/Compare 2 output Polarity.
refer to CC1P description</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2NP</name>
            <description>Capture/Compare 2 output Polarity.
Refer to CC1NP description</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3E</name>
            <description>Capture/Compare 3 output enable.
Refer to CC1E description</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3P</name>
            <description>Capture/Compare 3 output Polarity.
Refer to CC1P description</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC3NP</name>
            <description>Capture/Compare 3 output Polarity.
Refer to CC1NP description</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4E</name>
            <description>Capture/Compare 4 output enable.
refer to CC1E description</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4P</name>
            <description>Capture/Compare 4 output Polarity.
Refer to CC1P description</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC4NP</name>
            <description>Capture/Compare 4 output Polarity.
Refer to CC1NP description</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT_H</name>
              <description>High counter value (TIM2
              only)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>CNT_L</name>
              <description>Low counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>		  
        </register>
		<register>
          <name>CNT_ALTERNATE5</name>
          <displayName>CNT_ALTERNATE5</displayName>
          <description>counter</description>
		  <alternateRegister>CNT</alternateRegister>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
             <field>
                <name>CNT</name>
                <description>Most significant part counter value (TIM2)
nullLeast significant part of counter value</description>
                <bitOffset>0</bitOffset>
                <bitWidth>31</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>UIFCPY</name>
                <description>UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register</description>
                <bitOffset>31</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
          </fields>		  
        </register>				
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <fields>
          <field>
            <name>ARR</name>
            <description>High auto-reload value (TIM2)
nullLow Auto-reload value
ARR is the value to be loaded in the actual auto-reload register.
Refer to the  for more details about ARR update and behavior.
The counter is blocked while the auto-reload value is null.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>capture/compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>CCR1</name>
            <description>High Capture/Compare 1 value (TIM2)
nullLow Capture/Compare 1 value
If channel CC1 is configured as output:
CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
If channel CC1is configured as input:
CCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>capture/compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
           <field>
            <name>CCR2</name>
            <description>High Capture/Compare 2 value (TIM2)
nullLow Capture/Compare 2 value
If channel CC2 is configured as output:
CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output.
If channel CC2 is configured as input:
CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCR3</name>
          <displayName>CCR3</displayName>
          <description>capture/compare register 3</description>
          <addressOffset>0x3C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
           <field>
            <name>CCR3</name>
            <description>High Capture/Compare 3 value (TIM2)
nullLow Capture/Compare value
If channel CC3 is configured as output:
CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output.
If channel CC3is configured as input:
CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCR4</name>
          <displayName>CCR4</displayName>
          <description>capture/compare register 4</description>
          <addressOffset>0x40</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
           <field>
            <name>CCR4</name>
            <description>High Capture/Compare 4 value (TIM2)
nullLow Capture/Compare value
if CC4 channel is configured as output (CC4S bits):
CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).
It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.
The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output.
if CC4 channel is configured as input (CC4S bits in TIMx_CCMR4 register):
CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>DMA control register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>DBA</name>
            <description>DMA base address
This 5-bit vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...
Example: Let us consider the following transfer: DBL = 7 transfers &amp; DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DBL</name>
            <description>DMA burst length
This 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).
...</description>
            <bitOffset>8</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAR</name>
          <displayName>DMAR</displayName>
          <description>DMA address for full transfer</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>DMAB</name>
              <description>DMA register for burst
              accesses</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>OR1</name>
          <displayName>OR1</displayName>
          <description>TIM option register</description>
          <addressOffset>0x50</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>OCREF_CLR</name>
            <description>Ocref_clr source selection
This bit selects the ocref_clr input source.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AF1</name>
          <displayName>AF1</displayName>
          <description>TIM alternate function option register
          1</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>ETRSEL</name>
            <description>ETR source selection
These bits select the ETR input source.
Others: Reserved</description>
            <bitOffset>14</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TISEL</name>
          <displayName>TISEL</displayName>
          <description>TIM alternate function option register
          1</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
          <field>
            <name>TI1SEL</name>
            <description>TI1[0] to TI1[15] input selection
These bits select the TI1[0] to TI1[15] input source.
Others: Reserved</description>
            <bitOffset>0</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI2SEL</name>
            <description>TI2[0] to TI2[15] input selection
These bits select the TI2[0] to TI2[15] input source.
Others: Reserved</description>
            <bitOffset>8</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>	
	<peripheral>
      <name>TIM6</name>
      <description>Basic timers</description>
      <groupName>TIM</groupName>
      <baseAddress>0x40001000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM6_DAC</name>
        <description>TIM6 + LPTIM1 and DAC global
        interrupt</description>
        <value>17</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CEN</name>
            <description>Counter enable
Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
CEN is cleared automatically in one-pulse mode, when an update event occurs.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDIS</name>
            <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDIS</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Update event enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Update event disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>URS</name>
            <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>URS</name><usage>read-write</usage><enumeratedValue><name>AnyEvent</name><description>Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request</description><value>0</value></enumeratedValue><enumeratedValue><name>CounterOnly</name><description>Only counter overflow/underflow generates an update interrupt or DMA request</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OPM</name>
            <description>One-pulse mode</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OPM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter is not stopped at update event</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter stops counting at the next update event (clearing the CEN bit)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ARPE</name>
            <description>Auto-reload preload enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ARPE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMx_APRR register is not buffered</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMx_APRR register is buffered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UIFREMAP</name>
            <description>UIF status bit remapping</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>MMS</name>
            <description>Master mode selection
These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:
When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register).
Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>MMS</name><usage>read-write</usage><enumeratedValue><name>Reset</name><description>Use UG bit from TIMx_EGR register</description><value>0</value></enumeratedValue><enumeratedValue><name>Enable</name><description>Use CNT bit from TIMx_CEN register</description><value>1</value></enumeratedValue><enumeratedValue><name>Update</name><description>Use the update event</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>DMA/Interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>UIE</name>
            <description>Update interrupt enable</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDE</name>
            <description>Update DMA request enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update DMA request disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update DMA request enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>UIF</name>
            <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS&#160;=&#160;0 and UDIS&#160;=&#160;0 in the TIMx_CR1 register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>No update occurred</description><value>0</value></enumeratedValue><enumeratedValue><name>UpdatePending</name><description>Update interrupt pending.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>UG</name>
            <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            <enumeratedValues><name>UG</name><usage>read-write</usage><enumeratedValue><name>Update</name><description>Re-initializes the timer counter and generates an update of the registers.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
          <field>
            <name>CNT</name>
            <description>Counter value</description>
            <bitOffset>0</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          <field>
            <name>UIFCPY</name>
            <description>UIF Copy
This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.</description>
            <bitOffset>31</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>Prescaler value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="TIM6">
      <name>TIM7</name>
      <baseAddress>0x40001400</baseAddress>
      <interrupt>
        <name>TIM7</name>
        <description>TIM7 + LPTIM2 global interrupt</description>
        <value>18</value>
      </interrupt>
    </peripheral>
	<peripheral>
      <name>TIM14</name>
      <description>General purpose timers</description>
      <groupName>TIM</groupName>
      <baseAddress>0x40002000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM14</name>
        <description>TIM14 global interrupt</description>
        <value>19</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields> 
		  <field>
            <name>CEN</name>
            <description>Counter enable
Note: External clock and gated mode can work only if the CEN bit has been previously set by
software. However trigger mode can set the CEN bit automatically by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDIS</name>
            <description>Update disable
This bit is set and cleared by software to enable/disable update interrupt (UEV) event generation.
Counter overflow
Setting the UG bit.
Buffered registers are then loaded with their preload values.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDIS</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Update event enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Update event disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>URS</name>
            <description>Update request source
This bit is set and cleared by software to select the update interrupt (UEV) sources.
Counter overflow
Setting the UG bit</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>URS</name><usage>read-write</usage><enumeratedValue><name>AnyEvent</name><description>Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request</description><value>0</value></enumeratedValue><enumeratedValue><name>CounterOnly</name><description>Only counter overflow/underflow generates an update interrupt or DMA request</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OPM</name>
            <description>One-pulse mode</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OPM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter is not stopped at update event</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter stops counting at the next update event (clearing the CEN bit)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ARPE</name>
            <description>Auto-reload preload enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ARPE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMx_APRR register is not buffered</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMx_APRR register is buffered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CKD</name>
            <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CKD</name><usage>read-write</usage><enumeratedValue><name>Div1</name><description>t_DTS = t_CK_INT</description><value>0</value></enumeratedValue><enumeratedValue><name>Div2</name><description>t_DTS = 2 &#215; t_CK_INT</description><value>1</value></enumeratedValue><enumeratedValue><name>Div4</name><description>t_DTS = 4 &#215; t_CK_INT</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UIFREMAP</name>
            <description>UIF status bit remapping</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>DMA/Interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>UIE</name>
            <description>Update interrupt enable</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IE</name>
            <description>Capture/Compare 1 interrupt enable</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>UIF</name>
            <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow and if UDIS=&#226;&#128;&#153;0&#226;&#128;&#153; in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=&#226;&#128;&#153;0&#226;&#128;&#153; and UDIS=&#226;&#128;&#153;0&#226;&#128;&#153; in the TIMx_CR1 register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>No update occurred</description><value>0</value></enumeratedValue><enumeratedValue><name>UpdatePending</name><description>Update interrupt pending.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IF</name>
            <description>Capture/compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1OF</name>
            <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0&#226;&#128;&#153;.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>UG</name>
            <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            <enumeratedValues><name>UG</name><usage>read-write</usage><enumeratedValue><name>Update</name><description>Re-initializes the timer counter and generates an update of the registers.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1G</name>
            <description>Capture/compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Output</name>
          <displayName>CCMR1_Output</displayName>
          <description>capture/compare mode register 1 (output
          mode)</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1FE</name>
                <description>Output compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1PE</name>
                <description>Output compare 1 preload enable
Note: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1M</name>
                <description>Output compare 1 mode (refer to bit 16 for OC1M[3])
These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.
Others: Reserved
Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
          
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues><name>OC1M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
              <field>
                <name>OC1M_3</name>
                <description>Output compare 1 mode (refer to bit 16 for OC1M[3])
These bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.
Others: Reserved
Note: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode.
Note: The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
          
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Input</name>
          <displayName>CCMR1_Input</displayName>
          <description>capture/compare mode register 1 (input
          mode)</description>
          <alternateRegister>CCMR1_Output</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>CC1S</name>
            <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1PSC</name>
            <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1).
The prescaler is reset as soon as CC1E=&#226;&#128;&#153;0&#226;&#128;&#153; (TIMx_CCER register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1F</name>
            <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
            <bitOffset>4</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>capture/compare enable
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>CC1E</name>
            <description>Capture/Compare 1 output enable.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1P</name>
            <description>Capture/Compare 1 output Polarity.
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	This configuration is reserved, it must not be used.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NP</name>
            <description>Capture/Compare 1 complementary output Polarity.
CC1 channel configured as output: CC1NP must be kept cleared.
CC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>low counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
            <field>
              <name>UIFCPY</name>
              <description>UIF Copy</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>Low Auto-reload value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>capture/compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Low Capture/Compare 1
              value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TISEL</name>
          <displayName>TISEL</displayName>
          <description>TIM timer input selection
          register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>TI1SEL</name>
            <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
            <bitOffset>0</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
	<peripheral>
      <name>TIM15</name>
      <description>General purpose timers</description>
      <groupName>TIM</groupName>
      <baseAddress>0x40014000</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM15</name>
        <description>Timer 15 global interrupt</description>
        <value>20</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>CEN</name>
            <description>Counter enable
Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDIS</name>
            <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDIS</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Update event enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Update event disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>URS</name>
            <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>URS</name><usage>read-write</usage><enumeratedValue><name>AnyEvent</name><description>Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request</description><value>0</value></enumeratedValue><enumeratedValue><name>CounterOnly</name><description>Only counter overflow/underflow generates an update interrupt or DMA request</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OPM</name>
            <description>One-pulse mode</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OPM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter is not stopped at update event</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter stops counting at the next update event (clearing the CEN bit)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ARPE</name>
            <description>Auto-reload preload enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ARPE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMx_APRR register is not buffered</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMx_APRR register is buffered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CKD</name>
            <description>Clock division
This bitfield indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS) used by the dead-time generators and the digital filters (TIx)</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CKD</name><usage>read-write</usage><enumeratedValue><name>Div1</name><description>t_DTS = t_CK_INT</description><value>0</value></enumeratedValue><enumeratedValue><name>Div2</name><description>t_DTS = 2 &#215; t_CK_INT</description><value>1</value></enumeratedValue><enumeratedValue><name>Div4</name><description>t_DTS = 4 &#215; t_CK_INT</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UIFREMAP</name>
            <description>UIF status bit remapping</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CCPC</name>
            <description>Capture/compare preloaded control
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CCUS</name>
            <description>Capture/compare control update selection
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CCDS</name>
            <description>Capture/compare DMA selection</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MMS</name>
            <description>Master mode selection
These bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:</description>
            <bitOffset>4</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI1S</name>
            <description>TI1 selection</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS1</name>
            <description>Output Idle state 1 (OC1 output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIM15_BDTR register).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS1N</name>
            <description>Output Idle state 1 (OC1N output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIM15_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS2</name>
            <description>Output idle state 2 (OC2 output)
Note: This bit cannot be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in the TIM15_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>				
        <register>
          <name>SMCR</name>
          <displayName>SMCR</displayName>
          <description>slave mode control register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>SMS1</name>
            <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Other codes: reserved.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=&#226;&#128;&#153;00100&#226;&#128;&#153;). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>0</bitOffset>
          
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TS1</name>
            <description>Trigger selection
This bit field selects the trigger input to be used to synchronize the counter.
Other: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
            <bitOffset>4</bitOffset>
          
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MSM</name>
            <description>Master/slave mode</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>SMS2</name>
            <description>Slave mode selection
When external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.
Other codes: reserved.
Note: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=&#226;&#128;&#153;00100&#226;&#128;&#153;). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.
Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.</description>
            <bitOffset>16</bitOffset>
          
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TS2</name>
            <description>Trigger selection
This bit field selects the trigger input to be used to synchronize the counter.
Other: Reserved
See  for more details on ITRx meaning for each Timer.
Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.</description>
            <bitOffset>20</bitOffset>
           
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>				
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>DMA/Interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UIE</name>
            <description>Update interrupt enable</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IE</name>
            <description>Capture/Compare 1 interrupt enable</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2IE</name>
            <description>Capture/Compare 2 interrupt enable</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>COMIE</name>
            <description>COM interrupt enable</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TIE</name>
            <description>Trigger interrupt enable</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BIE</name>
            <description>Break interrupt enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>UDE</name>
            <description>Update DMA request enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1DE</name>
            <description>Capture/Compare 1 DMA request enable</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2DE</name>
            <description>Capture/Compare 2 DMA request enable</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>COMDE</name>
            <description>COM DMA request enable</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TDE</name>
            <description>Trigger DMA request enable</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UIF</name>
            <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by a trigger event (refer to control register (TIM15_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>No update occurred</description><value>0</value></enumeratedValue><enumeratedValue><name>UpdatePending</name><description>Update interrupt pending.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IF</name>
            <description>Capture/Compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2IF</name>
            <description>Capture/Compare 2 interrupt flag
refer to CC1IF description</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          <field>
            <name>COMIF</name>
            <description>COM interrupt flag
This flag is set by hardware on a COM event (once the capture/compare control bits &#226;&#128;&#147;CCxE, CCxNE, OCxM&#226;&#128;&#147; have been updated). It is cleared by software.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TIF</name>
            <description>Trigger interrupt flag
This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode, both edges in case gated mode is selected). It is set when the counter starts or stops when gated mode is selected. It is cleared by software.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BIF</name>
            <description>Break interrupt flag
This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1OF</name>
            <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0&#226;&#128;&#153;.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2OF</name>
            <description>Capture/Compare 2 overcapture flag
Refer to CC1OF description</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            
          </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UG</name>
            <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            <enumeratedValues><name>UG</name><usage>read-write</usage><enumeratedValue><name>Update</name><description>Re-initializes the timer counter and generates an update of the registers.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1G</name>
            <description>Capture/Compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>CC2G</name>
            <description>Capture/Compare 2 generation
Refer to CC1G description</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>COMG</name>
            <description>Capture/Compare control update generation
This bit can be set by software, it is automatically cleared by hardware.
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TG</name>
            <description>Trigger generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>BG</name>
            <description>Break generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Output</name>
          <displayName>CCMR1_Output</displayName>
          <description>capture/compare mode register (output
          mode)</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		    <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1FE</name>
                <description>Output Compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1PE</name>
                <description>Output Compare 1 preload enable
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1M1</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
On channels that have a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
              
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>CC2S</name>
                <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>8</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC2FE</name>
                <description>Output Compare 2 fast enable</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2PE</name>
                <description>Output Compare 2 preload enable</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>OC2M</name>
                <description>Output Compare 2 mode</description>
                <bitOffset>12</bitOffset>
             
                <bitWidth>3</bitWidth>
                <access>read-write</access>
              <enumeratedValues><name>OC2M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs / OpmMode1: Retriggerable OPM mode 1 - In up-counting mode, the channel is active until a trigger event is detected (on TRGI signal). In down-counting mode, the channel is inactive</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register / OpmMode2: Inversely to OpmMode1</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register / Reserved</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy / Reserved</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low / CombinedPwmMode1: OCyREF has the same behavior as in PWM mode 1. OCyREFC is the logical OR between OC1REF and OC2REF</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high / CombinedPwmMode2: OCyREF has the same behavior as in PWM mode 2. OCyREFC is the logical AND between OC1REF and OC2REF</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active / Reserved</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1 / Reserved</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
              <field>
                <name>OC1M2</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
On channels that have a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
        
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC2M_3</name>
                <description>Output Compare 2 mode</description>
                <bitOffset>24</bitOffset>
       
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              <enumeratedValues><name>OC2M_3</name><usage>read-write</usage><enumeratedValue><name>Normal</name><description>Normal output compare mode (modes 0-7)</description><value>0</value></enumeratedValue><enumeratedValue><name>Extended</name><description>Extended output compare mode (modes 7-15)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Input</name>
          <displayName>CCMR1_Input</displayName>
          <description>capture/compare mode register 1 (input
          mode)</description>
          <alternateRegister>CCMR1_Output</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		  <field>
            <name>CC1S</name>
            <description>Capture/Compare 1 Selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC1S bits are writable only when the channel is OFF (CC1E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1PSC</name>
            <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=&#226;&#128;&#153;0&#226;&#128;&#153; (TIMx_CCER register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1F</name>
            <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
            <bitOffset>4</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2S</name>
            <description>Capture/Compare 2 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Note: CC2S bits are writable only when the channel is OFF (CC2E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC2PSC</name>
            <description>Input capture 2 prescaler</description>
            <bitOffset>10</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>IC2F</name>
            <description>Input capture 2 filter</description>
            <bitOffset>12</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>capture/compare enable
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>CC1E</name>
            <description>Capture/Compare 1 output enable
When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1P</name>
            <description>Capture/Compare 1 output polarity
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0: this configuration is reserved, it must not be used.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NE</name>
            <description>Capture/Compare 1 complementary output enable</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NP</name>
            <description>Capture/Compare 1 complementary output polarity
CC1 channel configured as output:
CC1 channel configured as input:
This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer
to CC1P description.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#157;00&#226;&#128;&#157; (the channel is configured in output).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC2E</name>
            <description>Capture/Compare 2 output enable
Refer to CC1E description</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2P</name>
            <description>Capture/Compare 2 output polarity
Refer to CC1P description</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>CC2NP</name>
            <description>Capture/Compare 2 complementary output polarity
Refer to CC1NP description</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UIFCPY</name>
              <description>UIF Copy</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>Auto-reload value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>REP</name>
              <description>Repetition counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>capture/compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Capture/Compare 1 value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>				
        <register>
          <name>CCR2</name>
          <displayName>CCR2</displayName>
          <description>capture/compare register 2</description>
          <addressOffset>0x38</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR2</name>
              <description>Capture/Compare 2 value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>								
        <register>
          <name>BDTR</name>
          <displayName>BDTR</displayName>
          <description>break and dead-time register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>DTG</name>
            <description>Dead-time generator setup
This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.
DTG[7:5]=0xx =&gt; DT=DTG[7:0]x tdtg with tdtg=tDTS
DTG[7:5]=10x =&gt; DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS
DTG[7:5]=110 =&gt; DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS
DTG[7:5]=111 =&gt; DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS
Example if TDTS=125ns (8MHz), dead-time possible values are:
0 to 15875 ns by 125 ns steps,
16 &#194;&#181;s to 31750 ns by 250 ns steps,
32 &#194;&#181;s to 63 &#194;&#181;s by 1 &#194;&#181;s steps,
64 &#194;&#181;s to 126 &#194;&#181;s by 2 &#194;&#181;s steps
Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>LOCK</name>
            <description>Lock configuration
These bits offer a write protection against software errors.
Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OSSI</name>
            <description>Off-state selection for Idle mode
This bit is used when MOE=0 on channels configured as outputs.
See OC/OCN enable description for more details (enable register (TIM15_CCER) on page&#194;&#160;818).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OSSR</name>
            <description>Off-state selection for Run mode
This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
See OC/OCN enable description for more details (enable register (TIM15_CCER) on page&#194;&#160;818).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKE</name>
            <description>Break enable
1; Break inputs (BRK and CCS clock failure event) enabled
This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKP</name>
            <description>Break polarity
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>AOE</name>
            <description>Automatic output enable
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MOE</name>
            <description>Main output enable
This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
See OC/OCN enable description for more details (enable register (TIM15_CCER) on page&#194;&#160;818).</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKF</name>
            <description>Break filter
This bit-field defines the frequency used to sample the BRK input signal and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>16</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKDSRM</name>
            <description>Break Disarm
This bit is cleared by hardware when no break source is active.
The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>26</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKBID</name>
            <description>Break Bidirectional
In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>28</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>DMA control register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>DBA</name>
            <description>DMA base address
This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DBL</name>
            <description>DMA burst length
This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).
...</description>
            <bitOffset>8</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAR</name>
          <displayName>DMAR</displayName>
          <description>DMA address for full transfer</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>DMAB</name>
              <description>DMA register for burst
              accesses</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
		<register>
          <name>AF1</name>
          <displayName>AF1</displayName>
          <description>TIM15 alternate register 1</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
		  <field>
            <name>BKINE</name>
            <description>BRK BKIN input enable
This bit enables the BKIN alternate function input for the timer&#226;&#128;&#153;s BRK input. BKIN input is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP1E</name>
            <description>BRK COMP1 enable
This bit enables the COMP1 for the timer&#226;&#128;&#153;s BRK input. COMP1 output is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP2E</name>
            <description>BRK COMP2 enable
This bit enables the COMP2 for the timer&#226;&#128;&#153;s BRK input. COMP2 output is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKINP</name>
            <description>BRK BKIN input polarity
This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP1P</name>
            <description>BRK COMP1 input polarity
This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP2P</name>
            <description>BRK COMP2 input polarity
This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TISEL</name>
          <displayName>TISEL</displayName>
          <description>input selection register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>TI1SEL</name>
            <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
            <bitOffset>0</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TI2SEL</name>
            <description>selects TI2[0] to TI2[15] input
Others: Reserved</description>
            <bitOffset>8</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>		      			     		
      </registers>
    </peripheral>
	<peripheral>
      <name>TIM16</name>
      <description>General purpose timers</description>
      <groupName>TIM</groupName>
      <baseAddress>0x40014400</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>TIM16</name>
        <description>TIM16 global interrupt</description>
        <value>21</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1</name>
          <displayName>CR1</displayName>
          <description>control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CEN</name>
            <description>Counter enable
Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CEN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UDIS</name>
            <description>Update disable
This bit is set and cleared by software to enable/disable UEV event generation.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller
Buffered registers are then loaded with their preload values.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UDIS</name><usage>read-write</usage><enumeratedValue><name>Enabled</name><description>Update event enabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Disabled</name><description>Update event disabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>URS</name>
            <description>Update request source
This bit is set and cleared by software to select the UEV event sources.
Counter overflow/underflow
Setting the UG bit
Update generation through the slave mode controller</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>URS</name><usage>read-write</usage><enumeratedValue><name>AnyEvent</name><description>Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request</description><value>0</value></enumeratedValue><enumeratedValue><name>CounterOnly</name><description>Only counter overflow/underflow generates an update interrupt or DMA request</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>OPM</name>
            <description>One pulse mode</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>OPM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Counter is not stopped at update event</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Counter stops counting at the next update event (clearing the CEN bit)</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>ARPE</name>
            <description>Auto-reload preload enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>ARPE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>TIMx_APRR register is not buffered</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>TIMx_APRR register is buffered</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CKD</name>
            <description>Clock division
This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>CKD</name><usage>read-write</usage><enumeratedValue><name>Div1</name><description>t_DTS = t_CK_INT</description><value>0</value></enumeratedValue><enumeratedValue><name>Div2</name><description>t_DTS = 2 &#215; t_CK_INT</description><value>1</value></enumeratedValue><enumeratedValue><name>Div4</name><description>t_DTS = 4 &#215; t_CK_INT</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>UIFREMAP</name>
            <description>UIF status bit remapping</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CCPC</name>
            <description>Capture/compare preloaded control
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CCUS</name>
            <description>Capture/compare control update selection
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CCDS</name>
            <description>Capture/compare DMA selection</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS1</name>
            <description>Output Idle state 1 (OC1 output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OIS1N</name>
            <description>Output Idle state 1 (OC1N output)
Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIER</name>
          <displayName>DIER</displayName>
          <description>DMA/Interrupt enable register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>UIE</name>
            <description>Update interrupt enable</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Update interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Update interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IE</name>
            <description>Capture/Compare 1 interrupt enable</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>COMIE</name>
            <description>COM interrupt enable</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BIE</name>
            <description>Break interrupt enable</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>UDE</name>
            <description>Update DMA request enable</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1DE</name>
            <description>Capture/Compare 1 DMA request enable</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>status register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>UIF</name>
            <description>Update interrupt flag
This bit is set by hardware on an update event. It is cleared by software.
At overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.
When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>UIF</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>No update occurred</description><value>0</value></enumeratedValue><enumeratedValue><name>UpdatePending</name><description>Update interrupt pending.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1IF</name>
            <description>Capture/Compare 1 interrupt flag
This flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).
If channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.
If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>COMIF</name>
            <description>COM interrupt flag
This flag is set by hardware on a COM event (once the capture/compare control bits &#226;&#128;&#147;CCxE, CCxNE, OCxM&#226;&#128;&#147; have been updated). It is cleared by software.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BIF</name>
            <description>Break interrupt flag
This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1OF</name>
            <description>Capture/Compare 1 overcapture flag
This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0&#226;&#128;&#153;.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EGR</name>
          <displayName>EGR</displayName>
          <description>event generation register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>UG</name>
            <description>Update generation
This bit can be set by software, it is automatically cleared by hardware.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            <enumeratedValues><name>UG</name><usage>read-write</usage><enumeratedValue><name>Update</name><description>Re-initializes the timer counter and generates an update of the registers.</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field>
            <name>CC1G</name>
            <description>Capture/Compare 1 generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.
If channel CC1 is configured as output:
CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.
If channel CC1 is configured as input:
The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>COMG</name>
            <description>Capture/Compare control update generation
This bit can be set by software, it is automatically cleared by hardware.
Note: This bit acts only on channels that have a complementary output.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          <field>
            <name>BG</name>
            <description>Break generation
This bit is set by software in order to generate an event, it is automatically cleared by hardware.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Output</name>
          <displayName>CCMR1_Output</displayName>
          <description>capture/compare mode register (output
          mode)</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		     <field>
                <name>CC1S</name>
                <description>Capture/Compare 1 selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Others: Reserved
Note: CC1S bits are writable only when the channel is OFF (CC1E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
                <bitOffset>0</bitOffset>
                <bitWidth>2</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1FE</name>
                <description>Output Compare 1 fast enable
This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1PE</name>
                <description>Output Compare 1 preload enable
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OC1M</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
All other values: Reserved
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>4</bitOffset>
          
                <bitWidth>3</bitWidth>
                <access>read-write</access>
                <enumeratedValues><name>OC1M</name><usage>read-write</usage><enumeratedValue><name>Frozen</name><description>The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs</description><value>0</value></enumeratedValue><enumeratedValue><name>ActiveOnMatch</name><description>Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register</description><value>1</value></enumeratedValue><enumeratedValue><name>InactiveOnMatch</name><description>Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register</description><value>2</value></enumeratedValue><enumeratedValue><name>Toggle</name><description>OCyREF toggles when TIMx_CNT=TIMx_CCRy</description><value>3</value></enumeratedValue><enumeratedValue><name>ForceInactive</name><description>OCyREF is forced low</description><value>4</value></enumeratedValue><enumeratedValue><name>ForceActive</name><description>OCyREF is forced high</description><value>5</value></enumeratedValue><enumeratedValue><name>PwmMode1</name><description>In upcounting, channel is active as long as TIMx_CNT&lt;TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT&gt;TIMx_CCRy else active</description><value>6</value></enumeratedValue><enumeratedValue><name>PwmMode2</name><description>Inversely to PwmMode1</description><value>7</value></enumeratedValue></enumeratedValues>
            </field>
              <field>
                <name>OC1M_3</name>
                <description>Output Compare 1 mode
These bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.
All other values: Reserved
Note: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#153;00&#226;&#128;&#153; (the channel is configured in output).
In PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from &#226;&#128;&#156;frozen&#226;&#128;&#157; mode to &#226;&#128;&#156;PWM&#226;&#128;&#157; mode.
The OC1M[3] bit is not contiguous, located in bit 16.</description>
                <bitOffset>16</bitOffset>
              
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
          </fields>
        </register>
        <register>
          <name>CCMR1_Input</name>
          <displayName>CCMR1_Input</displayName>
          <description>capture/compare mode register 1 (input
          mode)</description>
          <alternateRegister>CCMR1_Output</alternateRegister>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
		   <field>
            <name>CC1S</name>
            <description>Capture/Compare 1 Selection
This bit-field defines the direction of the channel (input/output) as well as the used input.
Others: Reserved
Note: CC1S bits are writable only when the channel is OFF (CC1E = '0&#226;&#128;&#153; in TIMx_CCER).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1PSC</name>
            <description>Input capture 1 prescaler
This bit-field defines the ratio of the prescaler acting on CC1 input (IC1).
The prescaler is reset as soon as CC1E=&#226;&#128;&#153;0&#226;&#128;&#153; (TIMx_CCER register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IC1F</name>
            <description>Input capture 1 filter
This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:</description>
            <bitOffset>4</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCER</name>
          <displayName>CCER</displayName>
          <description>capture/compare enable
          register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>CC1E</name>
            <description>Capture/Compare 1 output enable
When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1P</name>
            <description>Capture/Compare 1 output polarity
When CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.
CC1NP=0, CC1P=0:	non-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).
CC1NP=0, CC1P=1:	inverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).
CC1NP=1, CC1P=1:	non-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.
CC1NP=1, CC1P=0:	this configuration is reserved, it must not be used.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NE</name>
            <description>Capture/Compare 1 complementary output enable</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CC1NP</name>
            <description>Capture/Compare 1 complementary output polarity
CC1 channel configured as output:
CC1 channel configured as input:
This bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer
to the description of CC1P.
Note: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=&#226;&#128;&#157;00&#226;&#128;&#157; (the channel is configured in output).
On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNT</name>
          <displayName>CNT</displayName>
          <description>counter</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CNT</name>
              <description>counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UIFCPY</name>
              <description>UIF Copy</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PSC</name>
          <displayName>PSC</displayName>
          <description>prescaler</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>PSC</name>
              <description>Prescaler value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            <writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
          </fields>
        </register>
        <register>
          <name>ARR</name>
          <displayName>ARR</displayName>
          <description>auto-reload register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <fields>
            <field>
              <name>ARR</name>
              <description>Auto-reload value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>RCR</name>
          <displayName>RCR</displayName>
          <description>repetition counter register</description>
          <addressOffset>0x30</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>REP</name>
              <description>Repetition counter value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR1</name>
          <displayName>CCR1</displayName>
          <description>capture/compare register 1</description>
          <addressOffset>0x34</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>CCR1</name>
              <description>Capture/Compare 1 value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>BDTR</name>
          <displayName>BDTR</displayName>
          <description>break and dead-time register</description>
          <addressOffset>0x44</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>DTG</name>
            <description>Dead-time generator setup
This bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.
DTG[7:5]=0xx =&gt; DT=DTG[7:0]x tdtg with tdtg=tDTS
DTG[7:5]=10x =&gt; DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS
DTG[7:5]=110 =&gt; DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS
DTG[7:5]=111 =&gt; DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS
Example if TDTS=125ns (8MHz), dead-time possible values are:
0 to 15875 ns by 125 ns steps,
16 &#194;&#181;s to 31750 ns by 250 ns steps,
32 &#194;&#181;s to 63 &#194;&#181;s by 1 &#194;&#181;s steps,
64 &#194;&#181;s to 126 &#194;&#181;s by 2 &#194;&#181;s steps
Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>LOCK</name>
            <description>Lock configuration
These bits offer a write protection against software errors.
Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OSSI</name>
            <description>Off-state selection for Idle mode
This bit is used when MOE=0 on channels configured as outputs.
See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page&#194;&#160;846).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OSSR</name>
            <description>Off-state selection for Run mode
This bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.
See OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page&#194;&#160;846).
Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKE</name>
            <description>Break enable
1; Break inputs (BRK and CCS clock failure event) enabled
Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKP</name>
            <description>Break polarity
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>AOE</name>
            <description>Automatic output enable
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MOE</name>
            <description>Main output enable
This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page&#194;&#160;846).</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKF</name>
            <description>Break filter
This bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:
This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>16</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKDSRM</name>
            <description>Break Disarm
This bit is cleared by hardware when no break source is active.
The BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>26</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKBID</name>
            <description>Break Bidirectional
In the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.
Note: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.</description>
            <bitOffset>28</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DCR</name>
          <displayName>DCR</displayName>
          <description>DMA control register</description>
          <addressOffset>0x48</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>DBA</name>
            <description>DMA base address
This 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.
Example:
...
Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DBL</name>
            <description>DMA burst length
This 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).
...</description>
            <bitOffset>8</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAR</name>
          <displayName>DMAR</displayName>
          <description>DMA address for full transfer</description>
          <addressOffset>0x4C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>DMAB</name>
              <description>DMA register for burst
              accesses</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>AF1</name>
          <displayName>AF1</displayName>
          <description>TIM17 option register 1</description>
          <addressOffset>0x60</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <fields>
		   <field>
            <name>BKINE</name>
            <description>BRK BKIN input enable
This bit enables the BKIN alternate function input for the timer&#226;&#128;&#153;s BRK input. BKIN input is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP1E</name>
            <description>BRK COMP1 enable
This bit enables the COMP1 for the timer&#226;&#128;&#153;s BRK input. COMP1 output is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP2E</name>
            <description>BRK COMP2 enable
This bit enables the COMP2 for the timer&#226;&#128;&#153;s BRK input. COMP2 output is 'ORed&#226;&#128;&#153; with the other BRK sources.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKINP</name>
            <description>BRK BKIN input polarity
This bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP1P</name>
            <description>BRK COMP1 input polarity
This bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>BKCMP2P</name>
            <description>BRK COMP2 input polarity
This bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.
Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TISEL</name>
          <displayName>TISEL</displayName>
          <description>input selection register</description>
          <addressOffset>0x68</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>TI1SEL</name>
            <description>selects TI1[0] to TI1[15] input
Others: Reserved</description>
            <bitOffset>0</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="TIM16">
      <name>TIM17</name>
      <baseAddress>0x40014800</baseAddress>
      <interrupt>
        <name>TIM17</name>
        <description>TIM17 global interrupt</description>
        <value>22</value>
      </interrupt>
    </peripheral>
	<peripheral>
      <name>USART1</name>
      <description>Universal synchronous asynchronous receiver
      transmitter</description>
      <groupName>USART</groupName>
      <baseAddress>0x40013800</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>USART1</name>
        <description>USART1 global interrupt</description>
        <value>27</value>
      </interrupt>
      <registers>
        <register>
          <name>CR1_FIFO_ENABLED</name>
          <displayName>CR1_FIFO_ENABLED</displayName>
          <description>Control register 1</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>UE</name>
            <description>USART enable
When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>UESM</name>
            <description>USART enable in low-power mode
When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RE</name>
            <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TE</name>
            <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit ('0&#226;&#128;&#153; followed by '1&#226;&#128;&#153;) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1&#226;&#128;&#153;. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IDLEIE</name>
            <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RXFNEIE</name>
            <description>RXFIFO not empty interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TCIE</name>
            <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TXFNFIE</name>
            <description>TXFIFO not full interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>PEIE</name>
            <description>PE interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>PS</name>
            <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>PCE</name>
            <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M&#194;&#160;=&#194;&#160;1; 8th bit if M&#194;&#160;=&#194;&#160;0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>WAKE</name>
            <description>Receiver wakeup method
This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>M0</name>
            <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>MME</name>
            <description>Mute mode enable
This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CMIE</name>
            <description>Character match interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OVER8</name>
            <description>Oversampling mode
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DEDT</name>
            <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>16</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>DEAT</name>
            <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>21</bitOffset>
            <bitWidth>5</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>RTOIE</name>
            <description>Receiver timeout interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .</description>
            <bitOffset>26</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>EOBIE</name>
            <description>End of Block interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>27</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>M1</name>
            <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = '00&#226;&#128;&#153;: 1 start bit, 8 Data bits, n Stop bit
M[1:0] = '01&#226;&#128;&#153;: 1 start bit, 9 Data bits, n Stop bit
M[1:0] = '10&#226;&#128;&#153;: 1 start bit, 7 Data bits, n Stop bit
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
            <bitOffset>28</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          </field>
          <field>
            <name>FIFOEN</name>
            <description>FIFO mode enable
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
            <bitOffset>29</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TXFEIE</name>
            <description>TXFIFO empty interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>30</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RXFFIE</name>
            <description>RXFIFO Full interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>31</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
		<register>
          <name>CR1_FIFO_DISABLED</name>
          <displayName>CR1_FIFO_DISABLED</displayName>
          <description>Control register 1</description>
		  <alternateRegister>CR1_FIFO_ENABLED</alternateRegister>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		    <field>
                <name>UE</name>
                <description>USART enable
When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.
Note: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>UESM</name>
                <description>USART enable in low-power mode
When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.
Note: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>RE</name>
                <description>Receiver enable
This bit enables the receiver. It is set and cleared by software.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>TE</name>
                <description>Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
Note: During transmission, a low pulse on the TE bit ('0&#226;&#128;&#153; followed by '1&#226;&#128;&#153;) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1&#226;&#128;&#153;. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>IDLEIE</name>
                <description>IDLE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>RXNEIE</name>
                <description>Receive data register not empty
This bit is set and cleared by software.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>TCIE</name>
                <description>Transmission complete interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>TXEIE</name>
                <description>Transmit data register empty
This bit is set and cleared by software.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>PEIE</name>
                <description>PE interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>PS</name>
                <description>Parity selection
This bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>PCE</name>
                <description>Parity control enable
This bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M&#194;&#160;=&#194;&#160;1; 8th bit if M&#194;&#160;=&#194;&#160;0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>WAKE</name>
                <description>Receiver wakeup method
This bit determines the USART wakeup method from Mute mode. It is set or cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>M0</name>
                <description>Word length
This bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>MME</name>
                <description>Mute mode enable
This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>CMIE</name>
                <description>Character match interrupt enable
This bit is set and cleared by software.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>OVER8</name>
                <description>Oversampling mode
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>DEDT</name>
                <description>Driver Enable deassertion time
This 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
If the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>16</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>DEAT</name>
                <description>Driver Enable assertion time
This 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>21</bitOffset>
                <bitWidth>5</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>RTOIE</name>
                <description>Receiver timeout interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .</description>
                <bitOffset>26</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>EOBIE</name>
                <description>End of Block interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
                <bitOffset>27</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
              <field>
                <name>M1</name>
                <description>Word length
This bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.
M[1:0] = '00&#226;&#128;&#153;: 1 start bit, 8 Data bits, n Stop bit
M[1:0] = '01&#226;&#128;&#153;: 1 start bit, 9 Data bits, n Stop bit
M[1:0] = '10&#226;&#128;&#153;: 1 start bit, 7 Data bits, n Stop bit
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.</description>
                <bitOffset>28</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
              </field>
              <field>
                <name>FIFOEN</name>
                <description>FIFO mode enable
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.</description>
                <bitOffset>29</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
                </field>
          </fields>
        </register>		
        <register>
          <name>CR2</name>
          <displayName>CR2</displayName>
          <description>Control register 2</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>SLVEN</name>
            <description>Synchronous Slave mode enable
When the SLVEN bit is set, the synchronous slave mode is enabled.
Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DIS_NSS</name>
            <description>When the DIS_NSS bit is set, the NSS pin input is ignored.
Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ADDM7</name>
            <description>7-bit Address Detection/4-bit Address Detection
This bit is for selection between 4-bit address detection or 7-bit address detection.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0)
Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>LBDL</name>
            <description>LIN break detection length
This bit is for selection between 11 bit or 10 bit break detection.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>LBDIE</name>
            <description>LIN break detection interrupt enable
Break interrupt mask (break detection using break delimiter).
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>LBCL</name>
            <description>Last bit clock pulse
This bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in synchronous mode.
The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CPHA</name>
            <description>Clock phase
This bit is used to select the phase of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see  and )
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CPOL</name>
            <description>Clock polarity
This bit enables the user to select the polarity of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CLKEN</name>
            <description>Clock enable
This bit enables the user to enable the SCLK pin.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to .
In Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected:
UE = 0
SCEN = 1
GTPR configuration
CLKEN= 1
UE = 1</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>STOP</name>
            <description>stop bits
These bits are used for programming the stop bits.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>12</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>LINEN</name>
            <description>LIN mode enable
This bit is set and cleared by software.
The LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>SWAP</name>
            <description>Swap TX/RX pins
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RXINV</name>
            <description>RX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the RX line.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TXINV</name>
            <description>TX pin active level inversion
This bit is set and cleared by software.
This enables the use of an external inverter on the TX line.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>17</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DATAINV</name>
            <description>Binary data inversion
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>18</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>MSBFIRST</name>
            <description>Most significant bit first
This bit is set and cleared by software.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>19</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ABREN</name>
            <description>Auto baud rate enable
This bit is set and cleared by software.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>20</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ABRMOD</name>
            <description>Auto baud rate mode
These bits are set and cleared by software.
This bitfield can only be written when ABREN = 0 or the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If DATAINV&#194;&#160;=&#194;&#160;1 and/or MSBFIRST&#194;&#160;=&#194;&#160;1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)
If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>21</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RTOEN</name>
            <description>Receiver timeout enable
This bit is set and cleared by software.
When this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>23</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ADD</name>
            <description>Address of the USART node
ADD[7:4]:
These bits give the address of the USART node or a character code to be recognized.
They are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or low-power mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match.
These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
ADD[3:0]:
These bits give the address of the USART node or a character code to be recognized.
They are used for wakeup with address mark detection, in multiprocessor communication during Mute mode or low-power mode.
These bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>24</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>CR3</name>
          <displayName>CR3</displayName>
          <description>Control register 3</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		  <field>
            <name>EIE</name>
            <description>Error interrupt enable
Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE&#194;&#160;=&#194;&#160;1 or ORE&#194;&#160;=&#194;&#160;1 or NE&#194;&#160;=&#194;&#160;1 or UDR = 1 in the USART_ISR register).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IREN</name>
            <description>IrDA mode enable
This bit is set and cleared by software.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>IRLP</name>
            <description>IrDA low-power
This bit is used for selecting between normal and low-power IrDA modes
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>HDSEL</name>
            <description>Half-duplex selection
Selection of Single-wire Half-duplex mode
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>NACK</name>
            <description>Smartcard NACK enable
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>SCEN</name>
            <description>Smartcard mode enable
This bit is used for enabling Smartcard mode.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DMAR</name>
            <description>DMA enable receiver
This bit is set/reset by software</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DMAT</name>
            <description>DMA enable transmitter
This bit is set/reset by software</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RTSE</name>
            <description>RTS enable
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CTSE</name>
            <description>CTS enable
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0)
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>CTSIE</name>
            <description>CTS interrupt enable
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>ONEBIT</name>
            <description>One sample bit method enable
This bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>OVRDIS</name>
            <description>Overrun Disable
This bit is used to disable the receive overrun detection.
the ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: This control bit enables checking the communication flow w/o reading the data</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DDRE</name>
            <description>DMA Disable on Reception Error
This bit can only be written when the USART is disabled (UE=0).
Note: The reception errors are: parity error, framing error or noise error.</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DEM</name>
            <description>Driver enable mode
This bit enables the user to activate the external transceiver control, through the DE signal.
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>DEP</name>
            <description>Driver enable polarity selection
This bit can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>SCARCNT</name>
            <description>Smartcard auto-retry count
This bitfield specifies the number of retries for transmission and reception in Smartcard mode.
In transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).
In reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).
This bitfield must be programmed only when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
When the USART is enabled (UE&#194;&#160;=&#194;&#160;1), this bitfield may only be written to 0x0, in order to stop retransmission.
Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>17</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>WUS</name>
            <description>Wakeup from low-power mode interrupt flag selection
This bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page&#194;&#160;835.</description>
            <bitOffset>20</bitOffset>
            <bitWidth>2</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>WUFIE</name>
            <description>Wakeup from low-power mode interrupt enable
This bit is set and cleared by software.
Note: WUFIE must be set before entering in low-power mode.
If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page&#194;&#160;835.</description>
            <bitOffset>22</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TXFTIE</name>
            <description>TXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>23</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TCBGTIE</name>
            <description>Transmission Complete before guard time, interrupt enable
This bit is set and cleared by software.
Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>24</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RXFTCFG</name>
            <description>Receive FIFO threshold configuration
Remaining combinations: Reserved</description>
            <bitOffset>25</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>RXFTIE</name>
            <description>RXFIFO threshold interrupt enable
This bit is set and cleared by software.</description>
            <bitOffset>28</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>TXFTCFG</name>
            <description>TXFIFO threshold configuration
Remaining combinations: Reserved</description>
            <bitOffset>29</bitOffset>
            <bitWidth>3</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BRR</name>
          <displayName>BRR</displayName>
          <description>Baud rate register</description>
          <addressOffset>0xC</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>BRR</name>
            <description>USART baud rate</description>
            <bitOffset>0</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>GTPR</name>
          <displayName>GTPR</displayName>
          <description>Guard time and prescaler
          register</description>
          <addressOffset>0x10</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
           <field>
            <name>PSC</name>
            <description>Prescaler value
In IrDA low-power and normal IrDA mode:
PSC[7:0] = IrDA Normal and Low-Power baud rate
PSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is divided by the value given in the register (8 significant bits):
In Smartcard mode:
PSC[4:0]&#194;&#160;=&#194;&#160;Prescaler value
PSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:
...
0010&#194;&#160;0000: Divides the source clock by 32 (IrDA mode)
...
1111&#194;&#160;1111: Divides the source clock by 255 (IrDA mode)
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: Bits [7:5] must be kept cleared if Smartcard mode is used.
This bitfield is reserved and forced by hardware to '0&#226;&#128;&#153; when the Smartcard and IrDA modes are not supported. Refer to .</description>
            <bitOffset>0</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>GT</name>
            <description>Guard time value
This bitfield is used to program the Guard time value in terms of number of baud clock periods.
This is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.
This bitfield can only be written when the USART is disabled (UE&#194;&#160;=&#194;&#160;0).
Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>8</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
        <register>
          <name>RTOR</name>
          <displayName>RTOR</displayName>
          <description>Receiver timeout register</description>
          <addressOffset>0x14</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
		    <field>
              <name>RTO</name>
              <description>Receiver timeout value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
            </field>
            <field>
              <name>BLEN</name>
              <description>Block Length</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
            </field>        
          </fields>
        </register>
        <register>
          <name>RQR</name>
          <displayName>RQR</displayName>
          <description>Request register</description>
          <addressOffset>0x18</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>ABRRQ</name>
            <description>Auto baud rate request
Writing 1 to this bit resets the ABRF flag in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>SBKRQ</name>
            <description>Send break request
Writing 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.
Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>MMRQ</name>
            <description>Mute mode request
Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>RXFRQ</name>
            <description>Receive data flush request
Writing 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.
This enables to discard the received data without reading them, and avoid an overrun condition.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>TXFRQ</name>
            <description>Transmit data flush request
When FIFO mode is disabled, writing '1&#226;&#128;&#153; to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.
When FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.
Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          </fields>
        </register>
        <register>
          <name>ISR_FIFO_ENABLED</name>
          <displayName>ISR_FIFO_ENABLED</displayName>
          <description>Interrupt &amp; status
          register</description>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x008000C0</resetValue>
          <fields>
		   <field>
            <name>PE</name>
            <description>Parity error
This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.
An interrupt is generated if PEIE = 1 in the USART_CR1 register.
Note: This error is associated with the character in the USART_RDR.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>FE</name>
            <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register.
Note: This error is associated with the character in the USART_RDR.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>NE</name>
            <description>Noise detection flag
This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page&#194;&#160;861).
This error is associated with the character in the USART_RDR.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>ORE</name>
            <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.
An interrupt is generated if RXFNEIE&#194;&#160;=&#194;&#160;1 or EIE = 1 in the USART_CR1 register.
Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>IDLE</name>
            <description>Idle line detected
This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.
Note: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME&#194;&#160;=&#194;&#160;1), IDLE is set if the USART is not mute (RWU&#194;&#160;=&#194;&#160;0), whatever the Mute mode selected by the WAKE bit. If RWU&#194;&#160;=&#194;&#160;1, IDLE is not set.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>RXFNE</name>
            <description>RXFIFO not empty
RXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.
RXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.
An interrupt is generated if RXFNEIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>TC</name>
            <description>Transmission complete
This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.
It is set by hardware when the transmission of a frame containing data is complete and when TXFE is set.
An interrupt is generated if TCIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register.
TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>TXFNF</name>
            <description>TXFIFO not full
TXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.
An interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.
Note: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).
This bit is used during single buffer transmission.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>LBDF</name>
            <description>LIN break detection flag
This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.
An interrupt is generated if LBDIE = 1 in the USART_CR2 register.
Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>CTSIF</name>
            <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.
An interrupt is generated if CTSIE&#194;&#160;=&#194;&#160;1 in the USART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>CTS</name>
            <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
            <bitOffset>10</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>RTOF</name>
            <description>Receiver timeout
This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.
An interrupt is generated if RTOIE&#194;&#160;=&#194;&#160;1 in the USART_CR2 register.
In Smartcard mode, the timeout corresponds to the CWT or BWT timings.
Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.
The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.
If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>EOBF</name>
            <description>End of block flag
This bit is set by hardware when a complete block has been received (for example T&#194;&#160;=&#194;&#160;1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.
An interrupt is generated if the EOBIE&#194;&#160;=&#194;&#160;1 in the USART_CR2 register.
It is cleared by software, writing 1 to the EOBCF in the USART_ICR register.
Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>UDR</name>
            <description>SPI slave underrun error flag
In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.
Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>ABRE</name>
            <description>Auto baud rate error
This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)
It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
            <bitOffset>14</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>ABRF</name>
            <description>Auto baud rate flag
This bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE&#194;&#160;=&#194;&#160;1) (ABRE, RXFNE and FE are also set in this case)
It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
            <bitOffset>15</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>BUSY</name>
            <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
            <bitOffset>16</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>CMF</name>
            <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.
An interrupt is generated if CMIE&#194;&#160;=&#194;&#160;1in the USART_CR1 register.</description>
            <bitOffset>17</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>SBKF</name>
            <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
            <bitOffset>18</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>RWU</name>
            <description>Receiver wakeup from Mute mode
This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
            <bitOffset>19</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>WUF</name>
            <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.
An interrupt is generated if WUFIE&#194;&#160;=&#194;&#160;1 in the USART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
            <bitOffset>20</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>TEACK</name>
            <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.
It can be used when an idle frame request is generated by writing TE&#194;&#160;=&#194;&#160;0, followed by TE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register, in order to respect the TE&#194;&#160;=&#194;&#160;0 minimum period.</description>
            <bitOffset>21</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>REACK</name>
            <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.
It can be used to verify that the USART is ready for reception before entering low-power mode.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
            <bitOffset>22</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
          </field>
          <field>
            <name>TXFE</name>
            <description>TXFIFO empty
This bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.
An interrupt is generated if the TXFEIE bit &#194;&#160;=&#194;&#160;1 (bit 30) in the USART_CR1 register.</description>
            <bitOffset>23</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>RXFF</name>
            <description>RXFIFO full
This bit is set by hardware when the number of received data corresponds to RXFIFO&#194;&#160;size&#194;&#160;+&#194;&#160;1 (RXFIFO full + 1 data in the USART_RDR register.
An interrupt is generated if the RXFFIE bit &#194;&#160;=&#194;&#160;1 in the USART_CR1 register.</description>
            <bitOffset>24</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>TCBGT</name>
            <description>Transmission complete before guard time flag
This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.
It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE&#194;&#160;=&#194;&#160;1 in the USART_CR3 register.
This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1&#226;&#128;&#153;. Refer to on page&#194;&#160;835.</description>
            <bitOffset>25</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>RXFT</name>
            <description>RXFIFO threshold flag
This bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit &#194;&#160;=&#194;&#160;1 (bit 27) in the USART_CR3 register.
Note: When the RXFTCFG threshold is configured to '101&#226;&#128;&#153;, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.</description>
            <bitOffset>26</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          <field>
            <name>TXFT</name>
            <description>TXFIFO threshold flag
This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit &#194;&#160;=&#194;&#160;1 (bit 31) in the USART_CR3 register.</description>
            <bitOffset>27</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          </fields>
        </register>
		<register>
          <name>ISR_FIFO_DISABLED</name>
          <displayName>ISR_FIFO_DISABLED</displayName>
          <description>Interrupt &amp; status
          register</description>
		  <alternateRegister>ISR_FIFO_ENABLED</alternateRegister>
          <addressOffset>0x1C</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x000000C0</resetValue>
          <fields>
		    <field>
                <name>PE</name>
                <description>Parity error
This bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.
An interrupt is generated if PEIE = 1 in the USART_CR1 register.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>FE</name>
                <description>Framing error
This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.
When transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).
An interrupt is generated if EIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>NE</name>
                <description>Noise detection flag
This bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.
Note: This bit does not generate an interrupt as it appears at the same time as the RXNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.
When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page&#194;&#160;861).</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>ORE</name>
                <description>Overrun error
This bit is set by hardware when the data currently being received in the shift register is
ready to be transferred into the USART_RDR register while RXNE&#194;&#160;=&#194;&#160;1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.
An interrupt is generated if RXNEIE&#194;&#160;=&#194;&#160;1 or EIE &#194;&#160;=&#194;&#160; 1 in the USART_CR1 register.
Note: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.
This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>IDLE</name>
                <description>Idle line detected
This bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.
Note: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line occurs).
If Mute mode is enabled (MME&#194;&#160;=&#194;&#160;1), IDLE is set if the USART is not mute (RWU&#194;&#160;=&#194;&#160;0), whatever the Mute mode selected by the WAKE bit. If RWU&#194;&#160;=&#194;&#160;1, IDLE is not set.</description>
                <bitOffset>4</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>RXNE</name>
                <description>Read data register not empty
RXNE bit is set by hardware when the content of the USART_RDR shift register has been transferred to the USART_RDR register. It is cleared by reading from the USART_RDR register. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.
An interrupt is generated if RXNEIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register.</description>
                <bitOffset>5</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>TC</name>
                <description>Transmission complete
This bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.
It is set by hardware when the transmission of a frame containing data is complete and when TXE is set.
An interrupt is generated if TCIE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register.
TC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.</description>
                <bitOffset>6</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>TXE</name>
                <description>Transmit data register empty
TXE is set by hardware when the content of the USART_TDR register has been transferred into the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can also be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the data (only in Smartcard T&#194;&#160;=&#194;&#160;0 mode, in case of transmission failure).
An interrupt is generated if the TXEIE bit &#194;&#160;=&#194;&#160;1 in the USART_CR1 register.</description>
                <bitOffset>7</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>LBDF</name>
                <description>LIN break detection flag
This bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.
An interrupt is generated if LBDIE = 1 in the USART_CR2 register.
Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>8</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>CTSIF</name>
                <description>CTS interrupt flag
This bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.
An interrupt is generated if CTSIE&#194;&#160;=&#194;&#160;1 in the USART_CR3 register.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>9</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>CTS</name>
                <description>CTS flag
This bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.
Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.</description>
                <bitOffset>10</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>RTOF</name>
                <description>Receiver timeout
This bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.
An interrupt is generated if RTOIE&#194;&#160;=&#194;&#160;1 in the USART_CR2 register.
In Smartcard mode, the timeout corresponds to the CWT or BWT timings.
Note: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.
The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.
If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>11</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>EOBF</name>
                <description>End of block flag
This bit is set by hardware when a complete block has been received (for example T&#194;&#160;=&#194;&#160;1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.
An interrupt is generated if the EOBIE&#194;&#160;=&#194;&#160;1 in the USART_CR2 register.
It is cleared by software, writing 1 to the EOBCF in the USART_ICR register.
Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>12</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>UDR</name>
                <description>SPI slave underrun error flag
In slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.
Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>13</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>ABRE</name>
                <description>Auto baud rate error
This bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)
It is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>14</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>ABRF</name>
                <description>Auto baud rate flag
This bit is set by hardware when the automatic baud rate has been set (RXNE is also set, generating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed without success (ABRE&#194;&#160;=&#194;&#160;1) (ABRE, RXNE and FE are also set in this case)
It is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.
Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.</description>
                <bitOffset>15</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>BUSY</name>
                <description>Busy flag
This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).</description>
                <bitOffset>16</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>CMF</name>
                <description>Character match flag
This bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.
An interrupt is generated if CMIE&#194;&#160;=&#194;&#160;1in the USART_CR1 register.</description>
                <bitOffset>17</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>SBKF</name>
                <description>Send break flag
This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.</description>
                <bitOffset>18</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>RWU</name>
                <description>Receiver wakeup from Mute mode
This bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.
When wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>19</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
              <field>
                <name>WUF</name>
                <description>Wakeup from low-power mode flag
This bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.
An interrupt is generated if WUFIE&#194;&#160;=&#194;&#160;1 in the USART_CR3 register.
Note: When UESM is cleared, WUF flag is also cleared.
If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>20</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TEACK</name>
                <description>Transmit enable acknowledge flag
This bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.
It can be used when an idle frame request is generated by writing TE&#194;&#160;=&#194;&#160;0, followed by TE&#194;&#160;=&#194;&#160;1 in the USART_CR1 register, in order to respect the TE&#194;&#160;=&#194;&#160;0 minimum period.</description>
                <bitOffset>21</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>REACK</name>
                <description>Receive enable acknowledge flag
This bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.
It can be used to verify that the USART is ready for reception before entering low-power mode.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .</description>
                <bitOffset>22</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
              </field>
              <field>
                <name>TCBGT</name>
                <description>Transmission complete before guard time flag
This bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.
It is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE&#194;&#160;=&#194;&#160;1 in the USART_CR3 register.
This bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.
Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1&#226;&#128;&#153;. Refer to on page&#194;&#160;835.</description>
                <bitOffset>25</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-only</access>
                </field>
          </fields>
        </register>		
        <register>
          <name>ICR</name>
          <displayName>ICR</displayName>
          <description>Interrupt flag clear register</description>
          <addressOffset>0x20</addressOffset>
          <size>0x20</size>
          <access>write-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
		   <field>
            <name>PECF</name>
            <description>Parity error clear flag
Writing 1 to this bit clears the PE flag in the USART_ISR register.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>FECF</name>
            <description>Framing error clear flag
Writing 1 to this bit clears the FE flag in the USART_ISR register.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>NECF</name>
            <description>Noise detected clear flag
Writing 1 to this bit clears the NE flag in the USART_ISR register.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>ORECF</name>
            <description>Overrun error clear flag
Writing 1 to this bit clears the ORE flag in the USART_ISR register.</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>IDLECF</name>
            <description>Idle line detected clear flag
Writing 1 to this bit clears the IDLE flag in the USART_ISR register.</description>
            <bitOffset>4</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>TXFECF</name>
            <description>TXFIFO empty clear flag
Writing 1 to this bit clears the TXFE flag in the USART_ISR register.</description>
            <bitOffset>5</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>TCCF</name>
            <description>Transmission complete clear flag
Writing 1 to this bit clears the TC flag in the USART_ISR register.</description>
            <bitOffset>6</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>TCBGTCF</name>
            <description>Transmission complete before Guard time clear flag
Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>LBDCF</name>
            <description>LIN break detection clear flag
Writing 1 to this bit clears the LBDF flag in the USART_ISR register.
Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CTSCF</name>
            <description>CTS clear flag
Writing 1 to this bit clears the CTSIF flag in the USART_ISR register.
Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>RTOCF</name>
            <description>Receiver timeout clear flag
Writing 1 to this bit clears the RTOF flag in the USART_ISR register.
Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page&#194;&#160;835.</description>
            <bitOffset>11</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>EOBCF</name>
            <description>End of block clear flag
Writing 1 to this bit clears the EOBF flag in the USART_ISR register.
Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .</description>
            <bitOffset>12</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>UDRCF</name>
            <description>SPI slave underrun clear flag
Writing 1 to this bit clears the UDRF flag in the USART_ISR register.
Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to</description>
            <bitOffset>13</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>CMCF</name>
            <description>Character match clear flag
Writing 1 to this bit clears the CMF flag in the USART_ISR register.</description>
            <bitOffset>17</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          <field>
            <name>WUCF</name>
            <description>Wakeup from low-power mode clear flag
Writing 1 to this bit clears the WUF flag in the USART_ISR register.
Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page&#194;&#160;835.</description>
            <bitOffset>20</bitOffset>
            <bitWidth>1</bitWidth>
            <access>write-only</access>
          </field>
          </fields>
        </register>
        <register>
          <name>RDR</name>
          <displayName>RDR</displayName>
          <description>Receive data register</description>
          <addressOffset>0x24</addressOffset>
          <size>0x20</size>
          <access>read-only</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>RDR</name>
              <description>Receive data value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>TDR</name>
          <displayName>TDR</displayName>
          <description>Transmit data register</description>
          <addressOffset>0x28</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
              <name>TDR</name>
              <description>Transmit data value</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
            </field>
          </fields>
        </register>
        <register>
          <name>PRESC</name>
          <displayName>PRESC</displayName>
          <description>Prescaler register</description>
          <addressOffset>0x2C</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000</resetValue>
          <fields>
            <field>
            <name>PRESCALER</name>
            <description>Clock prescaler
The USART input clock can be divided by a prescaler factor:
Remaining combinations: Reserved
Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>4</bitWidth>
            <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="USART1">
      <name>USART2</name>
      <baseAddress>0x40004400</baseAddress>
      <interrupt>
        <name>USART2</name>
        <description>USART2 global interrupt</description>
        <value>28</value>
      </interrupt>
    </peripheral>
	<peripheral derivedFrom="USART1">
      <name>USART3</name>
      <baseAddress>0x40004800</baseAddress>
      <interrupt>
        <name>USART3_USART4_USART5_USART6_LPUART1</name>
        <description>USART3,4,5,6 and LPUART1 global interrupt</description>
        <value>29</value>
      </interrupt>
    </peripheral>
	<peripheral derivedFrom="USART1">
      <name>USART4</name>
      <baseAddress>0x40004C00</baseAddress>
    </peripheral>
	<peripheral derivedFrom="USART1">
      <name>USART5</name>
      <baseAddress>0x40005000</baseAddress>
    </peripheral>
	<peripheral derivedFrom="USART1">
      <name>USART6</name>
      <baseAddress>0x40013C00</baseAddress>
    </peripheral>		
	<peripheral>
      <name>VREFBUF</name>
      <description>System configuration controller</description>
      <groupName>VREFBUF</groupName>
      <baseAddress>0x40010030</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CSR</name>
          <displayName>CSR</displayName>
          <description>VREFBUF control and status
          register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <resetValue>0x00000002</resetValue>
          <fields>
           <field>
            <name>ENVR</name>
            <description>Voltage reference buffer mode enable
This bit is used to enable the voltage reference buffer mode.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>HIZ</name>
            <description>High impedance mode
This bit controls the analog switch to connect or not the VREF+ pin.
Refer to  for the mode descriptions depending on ENVR bit configuration.</description>
            <bitOffset>1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>VRS</name>
            <description>Voltage reference scale
This bit selects the value generated by the voltage reference buffer.</description>
            <bitOffset>2</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            </field>
          <field>
            <name>VRR</name>
            <description>Voltage reference buffer ready</description>
            <bitOffset>3</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CCR</name>
          <displayName>CCR</displayName>
          <description>VREFBUF calibration control
          register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
           <field>
            <name>TRIM</name>
            <description>Trimming code
These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows the tuning of the internal reference buffer voltage.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>6</bitWidth>
            <access>read-write</access>
          </field>
          </fields>
        </register>
      </registers>
    </peripheral>  
    <peripheral>
      <name>WWDG</name>
      <description>System window watchdog</description>
      <groupName>WWDG</groupName>
      <baseAddress>0x40002C00</baseAddress>
      <addressBlock>
        <offset>0x0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>WWDG</name>
        <description>Window watchdog interrupt</description>
        <value>0</value>
      </interrupt>
      <registers>
        <register>
          <name>CR</name>
          <displayName>CR</displayName>
          <description>Control register</description>
          <addressOffset>0x0</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000007F</resetValue>
          <fields>
		   <field>
            <name>T</name>
            <description>7-bit counter (MSB to LSB)
These bits contain the value of the watchdog counter, decremented every
(4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).</description>
            <bitOffset>0</bitOffset>
            <bitWidth>7</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>127</maximum></range></writeConstraint>
            </field>
          <field>
            <name>WDGA</name>
            <description>Activation bit
This bit is set by software and only cleared by hardware after a reset. When WDGA&#194;&#160;=&#194;&#160;1, the watchdog can generate a reset.</description>
            <bitOffset>7</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
            <enumeratedValues><name>WDGA</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Watchdog disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Watchdog enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CFR</name>
          <displayName>CFR</displayName>
          <description>Configuration register</description>
          <addressOffset>0x4</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x0000007F</resetValue>
          <fields>
		   <field>
            <name>W</name>
            <description>7-bit window value
These bits contain the window value to be compared with the down-counter.</description>
            <bitOffset>0</bitOffset>
            <bitWidth>7</bitWidth>
            <access>read-write</access>
          <writeConstraint><range><minimum>0</minimum><maximum>127</maximum></range></writeConstraint>
            </field>
          <field>
            <name>EWI</name>
            <description>Early wakeup interrupt
When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.</description>
            <bitOffset>9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
          
          <enumeratedValues><name>EWIW</name><usage>write</usage><enumeratedValue><name>Enable</name><description>interrupt occurs whenever the counter reaches the value 0x40</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
          <field><name>WDGTB</name><description>Timer base
The timebase of the prescaler can be modified as follows:</description><bitOffset>11</bitOffset><bitWidth>3</bitWidth><enumeratedValues><name>WDGTB</name><usage>read-write</usage><enumeratedValue><name>Div16</name><description>Counter clock (PCLK1 div 4096) div 16</description><value>4</value></enumeratedValue><enumeratedValue><name>Div32</name><description>Counter clock (PCLK1 div 4096) div 32</description><value>5</value></enumeratedValue><enumeratedValue><name>Div64</name><description>Counter clock (PCLK1 div 4096) div 64</description><value>6</value></enumeratedValue><enumeratedValue><name>Div128</name><description>Counter clock (PCLK1 div 4096) div 128</description><value>7</value></enumeratedValue><enumeratedValue><name>Div1</name><description>Counter clock (PCLK1 div 4096) div 1</description><value>0</value></enumeratedValue><enumeratedValue><name>Div2</name><description>Counter clock (PCLK1 div 4096) div 2</description><value>1</value></enumeratedValue><enumeratedValue><name>Div4</name><description>Counter clock (PCLK1 div 4096) div 4</description><value>2</value></enumeratedValue><enumeratedValue><name>Div8</name><description>Counter clock (PCLK1 div 4096) div 8</description><value>3</value></enumeratedValue></enumeratedValues>
            </field></fields>
        </register>
        <register>
          <name>SR</name>
          <displayName>SR</displayName>
          <description>Status register</description>
          <addressOffset>0x8</addressOffset>
          <size>0x20</size>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <fields>
            <field>
              <name>EWIF</name>
              <description>Early wakeup interrupt
              flag</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
            <enumeratedValues><name>EWIFR</name><usage>read</usage><enumeratedValue><name>Pending</name><description>The EWI Interrupt Service Routine has been triggered</description><value>1</value></enumeratedValue><enumeratedValue><name>Finished</name><description>The EWI Interrupt Service Routine has been serviced</description><value>0</value></enumeratedValue></enumeratedValues>
            <enumeratedValues><name>EWIFW</name><usage>write</usage><enumeratedValue><name>Finished</name><description>The EWI Interrupt Service Routine has been serviced</description><value>0</value></enumeratedValue></enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>	
  <peripheral><name>DMA1</name><description>DMA controller</description><groupName>DMA1</groupName><baseAddress>1073872896</baseAddress><addressBlock><offset>0</offset><size>1024</size><usage>registers</usage></addressBlock><registers><cluster><dim>7</dim><dimIncrement>0x14</dimIncrement><dimIndex>1,2,3,4,5,6,7</dimIndex><name>CH%s</name><description>Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers</description><addressOffset>0x8</addressOffset><register><name>CR</name><displayName>CCR1</displayName><description>DMA channel 1 configuration register</description><addressOffset>0x0</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>EN</name><description>Channel enable</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>EN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Channel disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Channel enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TCIE</name><description>Transfer complete interrupt enable</description><bitOffset>1</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>TCIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Transfer Complete interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Transfer Complete interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>HTIE</name><description>Half transfer interrupt enable</description><bitOffset>2</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>HTIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Half Transfer interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Half Transfer interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TEIE</name><description>Transfer error interrupt enable</description><bitOffset>3</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>TEIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Transfer Error interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Transfer Error interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>DIR</name><description>Data transfer direction</description><bitOffset>4</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>DIR</name><usage>read-write</usage><enumeratedValue><name>FromPeripheral</name><description>Read from peripheral</description><value>0</value></enumeratedValue><enumeratedValue><name>FromMemory</name><description>Read from memory</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CIRC</name><description>Circular mode</description><bitOffset>5</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CIRC</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Circular buffer disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Circular buffer enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>PINC</name><description>Peripherarl increment mode</description><bitOffset>6</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>PINC</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Increment mode disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Increment mode enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>MINC</name><description>Memory increment mode</description><bitOffset>7</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="PINC"/>
            </field>
            <field><name>PSIZE</name><description>Peripheral size</description><bitOffset>8</bitOffset><bitWidth>2</bitWidth><enumeratedValues><name>PSIZE</name><usage>read-write</usage><enumeratedValue><name>Bits8</name><description>8-bit size</description><value>0</value></enumeratedValue><enumeratedValue><name>Bits16</name><description>16-bit size</description><value>1</value></enumeratedValue><enumeratedValue><name>Bits32</name><description>32-bit size</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>MSIZE</name><description>Memory size</description><bitOffset>10</bitOffset><bitWidth>2</bitWidth><enumeratedValues derivedFrom="PSIZE"/>
            </field>
            <field><name>PL</name><description>Channel priority level</description><bitOffset>12</bitOffset><bitWidth>2</bitWidth><enumeratedValues><name>PL</name><usage>read-write</usage><enumeratedValue><name>Low</name><description>Low priority</description><value>0</value></enumeratedValue><enumeratedValue><name>Medium</name><description>Medium priority</description><value>1</value></enumeratedValue><enumeratedValue><name>High</name><description>High priority</description><value>2</value></enumeratedValue><enumeratedValue><name>VeryHigh</name><description>Very high priority</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>MEM2MEM</name><description>Memory to memory mode</description><bitOffset>14</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>MEM2MEM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Memory to memory mode disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Memory to memory mode enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            </fields></register>
        <register><name>NDTR</name><displayName>CNDTR1</displayName><description>DMA channel 1 number of data tegister</description><addressOffset>0x4</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>NDT</name><description>Number of data to transfer</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
            </fields></register>
        <register><name>PAR</name><displayName>CPAR1</displayName><description>DMA channel 1 peripheral address</description><addressOffset>0x8</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>PA</name><description>Peripheral address</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth></field>
            </fields></register>
        <register><name>MAR</name><displayName>CMAR1</displayName><description>DMA channel 1 memory address</description><addressOffset>0xc</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>MA</name><description>Memory address</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth></field>
            </fields></register>
        </cluster><register><name>ISR</name><displayName>ISR</displayName><description>low interrupt status register</description><addressOffset>0</addressOffset><size>32</size><access>read-only</access><resetValue>0</resetValue><fields><field><name>GIF1</name><description>Channel 1 global interrupt flag</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>GIF1</name><usage>read-write</usage><enumeratedValue><name>NoEvent</name><description>No transfer error, half event, complete event</description><value>0</value></enumeratedValue><enumeratedValue><name>Event</name><description>A transfer error, half event or complete event has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TCIF1</name><description>Channel 1 transfer complete flag</description><bitOffset>1</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>TCIF1</name><usage>read-write</usage><enumeratedValue><name>NotComplete</name><description>No transfer complete event</description><value>0</value></enumeratedValue><enumeratedValue><name>Complete</name><description>A transfer complete event has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>HTIF1</name><description>Channel 1 half transfer flag</description><bitOffset>2</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>HTIF1</name><usage>read-write</usage><enumeratedValue><name>NotHalf</name><description>No half transfer event</description><value>0</value></enumeratedValue><enumeratedValue><name>Half</name><description>A half transfer event has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TEIF1</name><description>Channel 1 transfer error flag</description><bitOffset>3</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>TEIF1</name><usage>read-write</usage><enumeratedValue><name>NoError</name><description>No transfer error</description><value>0</value></enumeratedValue><enumeratedValue><name>Error</name><description>A transfer error has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>GIF2</name><description>Channel 2 global interrupt flag</description><bitOffset>4</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF2</name><description>Channel 2 transfer complete flag</description><bitOffset>5</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF2</name><description>Channel 2 half transfer flag</description><bitOffset>6</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF2</name><description>Channel 2 transfer error flag</description><bitOffset>7</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF3</name><description>Channel 3 global interrupt flag</description><bitOffset>8</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF3</name><description>Channel 3 transfer complete flag</description><bitOffset>9</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF3</name><description>Channel 3 half transfer flag</description><bitOffset>10</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF3</name><description>Channel 3 transfer error flag</description><bitOffset>11</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF4</name><description>Channel 4 global interrupt flag</description><bitOffset>12</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF4</name><description>Channel 4 transfer complete flag</description><bitOffset>13</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF4</name><description>Channel 4 half transfer flag</description><bitOffset>14</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF4</name><description>Channel 4 transfer error flag</description><bitOffset>15</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF5</name><description>Channel 5 global interrupt flag</description><bitOffset>16</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF5</name><description>Channel 5 transfer complete flag</description><bitOffset>17</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF5</name><description>Channel 5 half transfer flag</description><bitOffset>18</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF5</name><description>Channel 5 transfer error flag</description><bitOffset>19</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF6</name><description>Channel 6 global interrupt flag</description><bitOffset>20</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF6</name><description>Channel 6 transfer complete flag</description><bitOffset>21</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF6</name><description>Channel 6 half transfer flag</description><bitOffset>22</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF6</name><description>Channel 6 transfer error flag</description><bitOffset>23</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF7</name><description>Channel 7 global interrupt flag</description><bitOffset>24</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF7</name><description>Channel 7 transfer complete flag</description><bitOffset>25</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF7</name><description>Channel 7 half transfer flag</description><bitOffset>26</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF7</name><description>Channel 7 transfer error flag</description><bitOffset>27</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            </fields></register>
        <register><name>IFCR</name><displayName>IFCR</displayName><description>high interrupt status register</description><addressOffset>4</addressOffset><size>32</size><access>read-only</access><resetValue>0</resetValue><fields><field><name>CGIF1</name><description>Clear channel 1 global interrupt flag</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CGIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CTCIF1</name><description>Clear channel 1 transfer complete flag</description><bitOffset>1</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CTCIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the TCIF flag in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CHTIF1</name><description>Clear channel 1 half transfer flag</description><bitOffset>2</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CHTIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the HTIF flag in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CTEIF1</name><description>Clear channel 1 transfer error flag</description><bitOffset>3</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CTEIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the TEIF flag in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CGIF2</name><description>Clear channel 2 global interrupt flag</description><bitOffset>4</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF2</name><description>Clear channel 2 transfer complete flag</description><bitOffset>5</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF2</name><description>Clear channel 2 half transfer flag</description><bitOffset>6</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF2</name><description>Clear channel 2 transfer error flag</description><bitOffset>7</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF3</name><description>Clear channel 3 global interrupt flag</description><bitOffset>8</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF3</name><description>Clear channel 3 transfer complete flag</description><bitOffset>9</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF3</name><description>Clear channel 3 half transfer flag</description><bitOffset>10</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF3</name><description>Clear channel 3 transfer error flag</description><bitOffset>11</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF4</name><description>Clear channel 4 global interrupt flag</description><bitOffset>12</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF4</name><description>Clear channel 4 transfer complete flag</description><bitOffset>13</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF4</name><description>Clear channel 4 half transfer flag</description><bitOffset>14</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF4</name><description>Clear channel 4 transfer error flag</description><bitOffset>15</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF5</name><description>Clear channel 5 global interrupt flag</description><bitOffset>16</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF5</name><description>Clear channel 5 transfer complete flag</description><bitOffset>17</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF5</name><description>Clear channel 5 half transfer flag</description><bitOffset>18</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF5</name><description>Clear channel 5 transfer error flag</description><bitOffset>19</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF6</name><description>Clear channel 6 global interrupt flag</description><bitOffset>20</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF6</name><description>Clear channel 6 transfer complete flag</description><bitOffset>21</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF6</name><description>Clear channel 6 half transfer flag</description><bitOffset>22</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF6</name><description>Clear channel 6 transfer error flag</description><bitOffset>23</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF7</name><description>Clear channel 7 global interrupt flag</description><bitOffset>24</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF7</name><description>Clear channel 7 transfer complete flag</description><bitOffset>25</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF7</name><description>Clear channel 7 half transfer flag</description><bitOffset>26</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF7</name><description>Clear channel 7 transfer error flag</description><bitOffset>27</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            </fields></register>
        </registers></peripheral>
    <peripheral><name>DMA2</name><description>DMA controller</description><groupName>DMA2</groupName><baseAddress>1073873920</baseAddress><addressBlock><offset>0</offset><size>1024</size><usage>registers</usage></addressBlock><registers><cluster><dim>5</dim><dimIncrement>0x14</dimIncrement><dimIndex>1,2,3,4,5</dimIndex><name>CH%s</name><description>Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers</description><addressOffset>0x8</addressOffset><register><name>CR</name><displayName>CCR1</displayName><description>DMA channel 1 configuration register</description><addressOffset>0x0</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>EN</name><description>Channel enable</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>EN</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Channel disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Channel enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TCIE</name><description>Transfer complete interrupt enable</description><bitOffset>1</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>TCIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Transfer Complete interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Transfer Complete interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>HTIE</name><description>Half transfer interrupt enable</description><bitOffset>2</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>HTIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Half Transfer interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Half Transfer interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TEIE</name><description>Transfer error interrupt enable</description><bitOffset>3</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>TEIE</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Transfer Error interrupt disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Transfer Error interrupt enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>DIR</name><description>Data transfer direction</description><bitOffset>4</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>DIR</name><usage>read-write</usage><enumeratedValue><name>FromPeripheral</name><description>Read from peripheral</description><value>0</value></enumeratedValue><enumeratedValue><name>FromMemory</name><description>Read from memory</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CIRC</name><description>Circular mode</description><bitOffset>5</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CIRC</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Circular buffer disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Circular buffer enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>PINC</name><description>Peripherarl increment mode</description><bitOffset>6</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>PINC</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Increment mode disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Increment mode enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>MINC</name><description>Memory increment mode</description><bitOffset>7</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="PINC"/>
            </field>
            <field><name>PSIZE</name><description>Peripheral size</description><bitOffset>8</bitOffset><bitWidth>2</bitWidth><enumeratedValues><name>PSIZE</name><usage>read-write</usage><enumeratedValue><name>Bits8</name><description>8-bit size</description><value>0</value></enumeratedValue><enumeratedValue><name>Bits16</name><description>16-bit size</description><value>1</value></enumeratedValue><enumeratedValue><name>Bits32</name><description>32-bit size</description><value>2</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>MSIZE</name><description>Memory size</description><bitOffset>10</bitOffset><bitWidth>2</bitWidth><enumeratedValues derivedFrom="PSIZE"/>
            </field>
            <field><name>PL</name><description>Channel priority level</description><bitOffset>12</bitOffset><bitWidth>2</bitWidth><enumeratedValues><name>PL</name><usage>read-write</usage><enumeratedValue><name>Low</name><description>Low priority</description><value>0</value></enumeratedValue><enumeratedValue><name>Medium</name><description>Medium priority</description><value>1</value></enumeratedValue><enumeratedValue><name>High</name><description>High priority</description><value>2</value></enumeratedValue><enumeratedValue><name>VeryHigh</name><description>Very high priority</description><value>3</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>MEM2MEM</name><description>Memory to memory mode</description><bitOffset>14</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>MEM2MEM</name><usage>read-write</usage><enumeratedValue><name>Disabled</name><description>Memory to memory mode disabled</description><value>0</value></enumeratedValue><enumeratedValue><name>Enabled</name><description>Memory to memory mode enabled</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            </fields></register>
        <register><name>NDTR</name><displayName>CNDTR1</displayName><description>DMA channel 1 number of data tegister</description><addressOffset>0x4</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>NDT</name><description>Number of data to transfer</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><writeConstraint><range><minimum>0</minimum><maximum>65535</maximum></range></writeConstraint>
            </field>
            </fields></register>
        <register><name>PAR</name><displayName>CPAR1</displayName><description>DMA channel 1 peripheral address</description><addressOffset>0x8</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>PA</name><description>Peripheral address</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth></field>
            </fields></register>
        <register><name>MAR</name><displayName>CMAR1</displayName><description>DMA channel 1 memory address</description><addressOffset>0xc</addressOffset><size>32</size><access>read-write</access><resetValue>0</resetValue><fields><field><name>MA</name><description>Memory address</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth></field>
            </fields></register>
        </cluster><register><name>ISR</name><displayName>ISR</displayName><description>low interrupt status register</description><addressOffset>0</addressOffset><size>32</size><access>read-only</access><resetValue>0</resetValue><fields><field><name>GIF1</name><description>Channel 1 global interrupt flag</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>GIF1</name><usage>read-write</usage><enumeratedValue><name>NoEvent</name><description>No transfer error, half event, complete event</description><value>0</value></enumeratedValue><enumeratedValue><name>Event</name><description>A transfer error, half event or complete event has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TCIF1</name><description>Channel 1 transfer complete flag</description><bitOffset>1</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>TCIF1</name><usage>read-write</usage><enumeratedValue><name>NotComplete</name><description>No transfer complete event</description><value>0</value></enumeratedValue><enumeratedValue><name>Complete</name><description>A transfer complete event has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>HTIF1</name><description>Channel 1 half transfer flag</description><bitOffset>2</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>HTIF1</name><usage>read-write</usage><enumeratedValue><name>NotHalf</name><description>No half transfer event</description><value>0</value></enumeratedValue><enumeratedValue><name>Half</name><description>A half transfer event has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>TEIF1</name><description>Channel 1 transfer error flag</description><bitOffset>3</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>TEIF1</name><usage>read-write</usage><enumeratedValue><name>NoError</name><description>No transfer error</description><value>0</value></enumeratedValue><enumeratedValue><name>Error</name><description>A transfer error has occured</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>GIF2</name><description>Channel 2 global interrupt flag</description><bitOffset>4</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF2</name><description>Channel 2 transfer complete flag</description><bitOffset>5</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF2</name><description>Channel 2 half transfer flag</description><bitOffset>6</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF2</name><description>Channel 2 transfer error flag</description><bitOffset>7</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF3</name><description>Channel 3 global interrupt flag</description><bitOffset>8</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF3</name><description>Channel 3 transfer complete flag</description><bitOffset>9</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF3</name><description>Channel 3 half transfer flag</description><bitOffset>10</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF3</name><description>Channel 3 transfer error flag</description><bitOffset>11</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF4</name><description>Channel 4 global interrupt flag</description><bitOffset>12</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF4</name><description>Channel 4 transfer complete flag</description><bitOffset>13</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF4</name><description>Channel 4 half transfer flag</description><bitOffset>14</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF4</name><description>Channel 4 transfer error flag</description><bitOffset>15</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            <field><name>GIF5</name><description>Channel 5 global interrupt flag</description><bitOffset>16</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="GIF1"/>
            </field>
            <field><name>TCIF5</name><description>Channel 5 transfer complete flag</description><bitOffset>17</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TCIF1"/>
            </field>
            <field><name>HTIF5</name><description>Channel 5 half transfer flag</description><bitOffset>18</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="HTIF1"/>
            </field>
            <field><name>TEIF5</name><description>Channel 5 transfer error flag</description><bitOffset>19</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues derivedFrom="TEIF1"/>
            </field>
            </fields></register>
        <register><name>IFCR</name><displayName>IFCR</displayName><description>high interrupt status register</description><addressOffset>4</addressOffset><size>32</size><access>read-only</access><resetValue>0</resetValue><fields><field><name>CGIF1</name><description>Clear channel 1 global interrupt flag</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CGIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CTCIF1</name><description>Clear channel 1 transfer complete flag</description><bitOffset>1</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CTCIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the TCIF flag in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CHTIF1</name><description>Clear channel 1 half transfer flag</description><bitOffset>2</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CHTIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the HTIF flag in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CTEIF1</name><description>Clear channel 1 transfer error flag</description><bitOffset>3</bitOffset><bitWidth>1</bitWidth><enumeratedValues><name>CTEIF1</name><usage>read-write</usage><enumeratedValue><name>Clear</name><description>Clears the TEIF flag in the ISR register</description><value>1</value></enumeratedValue></enumeratedValues>
            </field>
            <field><name>CGIF2</name><description>Clear channel 2 global interrupt flag</description><bitOffset>4</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF2</name><description>Clear channel 2 transfer complete flag</description><bitOffset>5</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF2</name><description>Clear channel 2 half transfer flag</description><bitOffset>6</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF2</name><description>Clear channel 2 transfer error flag</description><bitOffset>7</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF3</name><description>Clear channel 3 global interrupt flag</description><bitOffset>8</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF3</name><description>Clear channel 3 transfer complete flag</description><bitOffset>9</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF3</name><description>Clear channel 3 half transfer flag</description><bitOffset>10</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF3</name><description>Clear channel 3 transfer error flag</description><bitOffset>11</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF4</name><description>Clear channel 4 global interrupt flag</description><bitOffset>12</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF4</name><description>Clear channel 4 transfer complete flag</description><bitOffset>13</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF4</name><description>Clear channel 4 half transfer flag</description><bitOffset>14</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF4</name><description>Clear channel 4 transfer error flag</description><bitOffset>15</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            <field><name>CGIF5</name><description>Clear channel 5 global interrupt flag</description><bitOffset>16</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CGIF1"/>
            </field>
            <field><name>CTCIF5</name><description>Clear channel 5 transfer complete flag</description><bitOffset>17</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTCIF1"/>
            </field>
            <field><name>CHTIF5</name><description>Clear channel 5 half transfer flag</description><bitOffset>18</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CHTIF1"/>
            </field>
            <field><name>CTEIF5</name><description>Clear channel 5 transfer error flag</description><bitOffset>19</bitOffset><bitWidth>1</bitWidth><enumeratedValues derivedFrom="CTEIF1"/>
            </field>
            </fields></register>
        </registers></peripheral>
    </peripherals>
</device>